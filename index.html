<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>3DBitmap Driving Game</title>
    <style>
        html, body {
            height: 100%;
            margin: 0;
            background: #181818;
            color: #fff;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
        }
        #canvasContainer {
            position: absolute;
            top: 0; left: 0; width: 100vw; height: 100vh;
            background: #181818;
            z-index: 1;
        }
        #uiBar {
            position: absolute;
            top: 0; left: 0; width: 100vw;
            background: rgba(24,24,24,0.95);
            color: #ffa94d;
            padding: 8px 16px;
            z-index: 10;
            display: flex;
            align-items: center;
            gap: 18px;
            font-size: 1.1em;
        }
        #blockForm input[type="text"] {
            padding: 6px 10px;
            border-radius: 4px 0 0 4px;
            border: 1px solid #ffa94d;
            outline: none;
            font-size: 1em;
            width: 120px;
        }
        #blockForm button {
            padding: 6px 12px;
            border-radius: 0 4px 4px 0;
            border: none;
            background: #ffa94d;
            color: #181818;
            font-weight: bold;
            cursor: pointer;
            font-size: 1em;
        }
        #blockInfo {
            margin-left: 24px;
            font-size: 0.95em;
            color: #fff;
        }
        #loadingOverlay {
            position: fixed;
            top:0; left:0; width:100vw; height:100vh;
            background: rgba(16,16,24,0.95);
            color: #ffa94d;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 100;
            font-size: 1.3em;
            letter-spacing: 1px;
        }
        #loadingBar {
            width: 240px;
            height: 10px;
            background: #222;
            border-radius: 5px;
            margin-top: 18px;
            overflow: hidden;
        }
        #loadingBarProgress {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg,#f7931a,#ffa94d);
            transition: width 0.2s;
        }
        #instructions {
            position: absolute;
            bottom: 16px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(24,24,24,0.85);
            color: #ffa94d;
            padding: 8px 18px;
            border-radius: 8px;
            font-size: 1em;
            z-index: 10;
            pointer-events: none;
        }
        #multiplayer {
            position: absolute;
            top: 48px;
            right: 16px;
            background: rgba(24,24,24,0.85);
            color: #ffa94d;
            padding: 10px;
            border-radius: 8px;
            z-index: 10;
            width: 220px;
            text-align: center;
        }
        #multiplayer button {
            padding: 6px 12px;
            border-radius: 4px;
            border: none;
            background: #ffa94d;
            color: #181818;
            font-weight: bold;
            cursor: pointer;
            margin: 5px;
            font-size: 0.9em;
        }
        #peerId {
            font-size: 0.9em;
            word-break: break-all;
            background: #333;
            padding: 4px;
            border-radius: 2px;
            margin: 5px 0;
        }
        #playersList {
            font-size: 0.9em;
            text-align: left;
            margin-top: 5px;
        }
        #minimap {
            position: absolute;
            bottom: 16px;
            right: 16px;
            width: 200px;
            height: 200px;
            background: rgba(0,0,0,0.7);
            border: 2px solid #ffa94d;
            border-radius: 4px;
            overflow: hidden;
            z-index: 10;
        }
        .otherPlayerMarker {
            position: absolute;
            width: 6px;
            height: 6px;
            margin-left: -3px;
            margin-top: -3px;
            border-radius: 50%;
            border: 1px solid #fff;
        }
        .playerMarker {
            position: absolute;
            width: 8px;
            height: 8px;
            margin-left: -4px;
            margin-top: -4px;
            border-radius: 50%;
            border: 1px solid #fff;
            background: #ff0;
        }
        #gameUI {
            position: absolute;
            top: 50px;
            left: 16px;
            background: rgba(24,24,24,0.85);
            color: #ffa94d;
            padding: 8px 18px;
            border-radius: 8px;
            font-size: 1em;
            z-index: 10;
        }
        #gameUI .lives {
            font-size: 1.5em;
            color: #ff3333;
        }
        #gameUI .boost {
            margin-top: 5px;
            height: 8px;
            width: 100px;
            background: rgba(255,255,255,0.2);
            border-radius: 4px;
        }
        #gameUI .boost-bar {
            height: 100%;
            width: 100%;
            background: linear-gradient(90deg, #3366ff, #00ccff);
            border-radius: 4px;
            transition: width 0.2s;
        }
        #gameUI .score {
            margin-top: 5px;
            font-weight: bold;
        }
        #gameOverScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0,0,0,0.85);
            color: #ffa94d;
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 200;
        }
        #gameOverScreen h2 {
            font-size: 3em;
            margin-bottom: 20px;
        }
        #gameOverScreen button {
            padding: 10px 20px;
            border-radius: 5px;
            border: none;
            background: #ffa94d;
            color: #181818;
            font-weight: bold;
            font-size: 1.2em;
            cursor: pointer;
            margin-top: 20px;
        }
        .collectible {
            position: absolute;
            width: 30px;
            height: 30px;
            margin-left: -15px;
            margin-top: -15px;
            border-radius: 50%;
            background: radial-gradient(#ffcc00, #ff6600);
            box-shadow: 0 0 15px #ffcc00;
            animation: pulse 1s infinite alternate;
        }
        @keyframes pulse {
            from { transform: scale(1); }
            to { transform: scale(1.2); }
        }
    </style>
</head>
<body>
    <div id="canvasContainer"></div>
    <div id="uiBar">
        <form id="blockForm" style="display:inline-flex;">
            <input type="text" id="blockHash" value="676767" placeholder="Block # or hash">
            <button type="submit">Load</button>
        </form>
        <span id="blockInfo">Block: <span id="blockHeight">-</span> | TX: <span id="txCount">-</span> | BTC: <span id="totalBtc">-</span> | <span id="blockTime">-</span></span>
    </div>
    <div id="instructions">
        <b>Arrow keys</b> to drive. <b>Shift</b> to boost. <b>Load a block</b> to generate a new track!
    </div>
    <div id="loadingOverlay" style="display:none;">
        <div id="loadingText">Loading block data...</div>
        <div id="loadingBar"><div id="loadingBarProgress"></div></div>
    </div>
    <div id="multiplayer">
        <h3 style="margin-top:0">Multiplayer</h3>
        <div id="hostOptions">
            <button id="createGame">Create Game</button>
            <div id="gameCreated" style="display:none">
                <p>Share this game ID:</p>
                <div id="peerId"></div>
                <p>Connected players: <span id="playerCount">0</span></p>
            </div>
        </div>
        <div id="joinOptions">
            <p>- OR -</p>
            <input type="text" id="joinGameId" placeholder="Paste game ID">
            <button id="joinGame">Join Game</button>
        </div>
        <div id="connectionStatus"></div>
        <div id="playersList"></div>
    </div>
    <div id="minimap"></div>
    <div id="gameUI">
        <div>Lives: <span class="lives">❤️❤️❤️</span></div>
        <div>Boost: <div class="boost"><div class="boost-bar"></div></div></div>
        <div class="score">Score: 0</div>
    </div>
    <div id="gameOverScreen">
        <h2>GAME OVER</h2>
        <div class="final-score">Score: 0</div>
        <button id="restartGame">Try Again</button>
    </div>
    <script src="https://unpkg.com/peerjs@1.4.7/dist/peerjs.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
    // --- Minimal Block Data Fetch ---
    let storedTransactions = [];
    let blockMetadata = null;
    let cachedBlockHash = null; // cache the loaded block hash

    async function loadBlockData(blockHash) {
        // Only fetch and reload if not already loaded
        if (cachedBlockHash === blockHash && storedTransactions.length && blockMetadata) {
            showLoading(false, 100, "Block already loaded");
            return;
        }
        showLoading(true, 0, "Loading block data...");
        try {
            const apiUrl = `https://blockchain.info/rawblock/${blockHash}?cors=true`;
            const response = await fetch(apiUrl);
            if (!response.ok) throw new Error("Block not found");
            showLoading(true, 30, "Parsing block data...");
            const data = await response.json();
            storedTransactions = data.tx || [];
            blockMetadata = {
                height: data.height,
                hash: data.hash,
                time: data.time,
                tx_count: data.tx ? data.tx.length : 0
            };
            showLoading(true, 60, "Generating track...");
            updateBlockInfo(blockMetadata);
            createDrivingTrack(storedTransactions);
            showLoading(false, 100, "Done");
            cachedBlockHash = blockHash;
        } catch (e) {
            showLoading(true, 100, "Error: " + e.message);
            setTimeout(()=>showLoading(false), 1200);
        }
    }

    function updateBlockInfo(meta) {
        document.getElementById('blockHeight').textContent = meta.height || '-';
        document.getElementById('txCount').textContent = meta.tx_count || '-';
        let totalBtc = 0;
        if (storedTransactions && storedTransactions.length > 0) {
            storedTransactions.forEach(tx => {
                if (tx.out && Array.isArray(tx.out)) {
                    tx.out.forEach(output => { totalBtc += output.value || 0; });
                }
            });
            totalBtc = (totalBtc / 100000000).toFixed(8);
        }
        document.getElementById('totalBtc').textContent = totalBtc || '-';
        document.getElementById('blockTime').textContent = meta.time ? new Date(meta.time * 1000).toLocaleString() : '-';
    }

    function showLoading(show, percent, text) {
        const overlay = document.getElementById('loadingOverlay');
        overlay.style.display = show ? 'flex' : 'none';
        if (typeof percent === 'number') {
            document.getElementById('loadingBarProgress').style.width = percent + "%";
        }
        if (text) document.getElementById('loadingText').textContent = text;
    }

    // --- Driving Game Logic ---
    let scene, camera, renderer;
    let trackSegments = [];
    let car, carSpeed = 0, carMaxSpeed = 2.5, carSteer = 0, carAngle = 0;
    let carPosition = new THREE.Vector3(0, 5, 0);
    let carVelocity = new THREE.Vector3(0, 0, 0);
    let carDirection = new THREE.Vector3(0, 0, 1);
    let carOnGround = false;
    let cameraOffset = new THREE.Vector3(0, 10, -22);
    let keys = {};
    let gravity = -0.25;
    let friction = 0.98;
    let groundFriction = 0.92;
    let jumpPower = 0.0; // set to >0 for jump support
    let trackWidth = 16; // Increased width for easier driving
    let respawnPoint = null;

    // Game mechanics variables
    let lives = 3;
    let fallCount = 0;
    let gameOver = false;
    let score = 0;
    let boostAmount = 100;
    let boostRechargeRate = 0.5;
    let boostDepletionRate = 1;
    let collectibles = [];
    let collectibleCount = 0;

    // Helper for smooth track connection (Catmull-Rom spline)
    function smoothTrackPoints(points) {
        // Adjust hills so there are no step ups/downs: smooth y between points
        // We'll use a moving average to smooth the y values
        let yVals = points.map(p => p.p1.y);
        let smoothYs = [];
        for (let i = 0; i < yVals.length; i++) {
            let sum = 0, count = 0;
            for (let j = -2; j <= 2; j++) {
                if (i + j >= 0 && i + j < yVals.length) {
                    sum += yVals[i + j];
                    count++;
                }
            }
            smoothYs[i] = sum / count;
        }
        // Set all p1.y and p2.y to the smoothed value for both ends of each segment
        for (let i = 0; i < points.length; i++) {
            points[i].p1.y = smoothYs[i];
            if (i < points.length - 1) {
                points[i].p2.y = smoothYs[i + 1];
            } else {
                points[i].p2.y = smoothYs[i];
            }
        }

        // Use CatmullRomCurve3 for smooth interpolation
        let curvePoints = points.map(p => p.p1.clone());
        curvePoints.push(points[points.length - 1].p2.clone());
        let curve = new THREE.CatmullRomCurve3(curvePoints, false, 'catmullrom', 0.5);
        let smooth = [];
        let N = points.length * 8;
        for (let i = 0; i < N; i++) {
            let t1 = i / N;
            let t2 = (i + 1) / N;
            let p1 = curve.getPoint(t1);
            let p2 = curve.getPoint(t2);
            let idx = Math.floor(t1 * points.length);
            let width = points[idx] ? points[idx].width : trackWidth;
            smooth.push({ p1, p2, width });
        }
        return smooth;
    }

    // --- ThreeJS Initialization ---
    function initThreeJS() {
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
        camera.position.set(0, 10, -30);
        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.getElementById('canvasContainer').appendChild(renderer.domElement);

        // Lighting
        scene.add(new THREE.AmbientLight(0x888888));
        let dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(10, 30, 10);
        scene.add(dirLight);

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    }

    // Helper for smooth track connection
    function lerpVec3(a, b, t) {
        return new THREE.Vector3(
            a.x + (b.x - a.x) * t,
            a.y + (b.y - a.y) * t,
            a.z + (b.z - a.z) * t
        );
    }

    // Generate flat track with smooth hills and turns
    function createDrivingTrack(transactions) {
        clearScene();
        trackSegments = [];
        let points = [];
        let pos = new THREE.Vector3(0, 0, 0);
        let angleY = 0;

        // 1. Generate points for each segment
        transactions.forEach((tx, i) => {
            let hashVal = parseInt(tx.hash.slice(-2), 16);
            let type = hashVal % 3; // 0: straight, 1: left, 2: right
            let length = 20 + ((tx.out ? tx.out.length : 1) * 5);
            let width = trackWidth;
            // Hill height based on tx value
            let value = tx.out ? tx.out.reduce((acc, cur) => acc + (cur.value || 0), 0) : 0;
            let hill = ((value / 1e8) % 1) * 12 - 6; // -6 to +6

            // Angle based on hash
            if (type === 1) angleY += Math.PI / 12;
            if (type === 2) angleY -= Math.PI / 12;

            // Next point
            let next = new THREE.Vector3(
                pos.x + Math.sin(angleY) * length,
                hill,
                pos.z + Math.cos(angleY) * length
            );
            points.push({ p1: pos.clone(), p2: next.clone(), width, angleY });
            pos = next;
        });

        // Smooth the track (no step up/downs)
        let smoothSegments = smoothTrackPoints(points);

        // Create segments
        for (let i = 0; i < smoothSegments.length; i++) {
            let { p1, p2, width } = smoothSegments[i];
            let segLen = p1.distanceTo(p2);
            let mid = lerpVec3(p1, p2, 0.5);
            let boxGeom = new THREE.BoxGeometry(width, 2, segLen);
            let color = 0x222222 + (i * 1000);
            let mat = new THREE.MeshPhongMaterial({ color: color });
            let mesh = new THREE.Mesh(boxGeom, mat);

            mesh.position.copy(mid);
            let dx = p2.x - p1.x, dz = p2.z - p1.z;
            mesh.rotation.y = Math.atan2(dx, dz);
            let dy = p2.y - p1.y;
            mesh.rotation.x = Math.atan2(dy, segLen);

            scene.add(mesh);
            trackSegments.push({ mesh, p1: p1.clone(), p2: p2.clone(), width, segLen });
        }

        // Place car at start
        createCar(smoothSegments[0].p1, Math.atan2(
            smoothSegments[0].p2.x - smoothSegments[0].p1.x,
            smoothSegments[0].p2.z - smoothSegments[0].p1.z
        ));
        // Store track points for collision
        trackSegments.trackPoints = smoothSegments;
        // Set respawn point to start
        respawnPoint = {
            pos: smoothSegments[0].p1.clone(),
            angle: Math.atan2(
                smoothSegments[0].p2.x - smoothSegments[0].p1.x,
                smoothSegments[0].p2.z - smoothSegments[0].p1.z
            )
        };

        // Re-add other players' meshes so they persist
        Object.values(otherPlayers).forEach(p => {
            scene.add(p.mesh);
        });

        // Reset game state for new track
        lives = 3;
        fallCount = 0;
        gameOver = false;
        score = 0;
        boostAmount = 100;
        updateGameUI();

        // Spawn collectibles on the new track
        spawnCollectibles();
    }

    function createCar(startPos, startAngle) {
        if (car) scene.remove(car);
        let geometry = new THREE.BoxGeometry(3, 2, 5);
        // Convert player color hex to number
        const colorNum = parseInt(playerColor.replace('#', '0x'), 16);
        let material = new THREE.MeshPhongMaterial({ 
            color: colorNum,
            emissive: new THREE.Color(colorNum).multiplyScalar(0.2) 
        });
        car = new THREE.Mesh(geometry, material);
        car.position.copy(startPos || new THREE.Vector3(0, 5, 0));
        car.rotation.y = startAngle || 0;
        
        // Add self label
        const label = createPlayerLabel('P' + playerIndices[playerId]);
        car.add(label);
        
        scene.add(car);
        carSpeed = 0;
        carAngle = startAngle || 0;
        carPosition.copy(car.position);
        carVelocity.set(0, 0, 0);
        carDirection.set(Math.sin(carAngle), 0, Math.cos(carAngle));
        
        // Initialize minimap
        initMinimap();
    }

    window.addEventListener('keydown', e => { keys[e.code] = true; });
    window.addEventListener('keyup', e => { keys[e.code] = false; });

    function updateGameUI() {
        // Update lives display
        const livesDisplay = document.querySelector('#gameUI .lives');
        const hearts = '❤️'.repeat(lives);
        livesDisplay.textContent = hearts;
        
        // Update boost bar
        const boostBar = document.querySelector('#gameUI .boost-bar');
        boostBar.style.width = boostAmount + '%';
        
        // Update score
        document.querySelector('#gameUI .score').textContent = 'Score: ' + score;
    }
    
    function showGameOver() {
        document.getElementById('gameOverScreen').style.display = 'flex';
        document.querySelector('#gameOverScreen .final-score').textContent = 'Score: ' + score;
        gameOver = true;
    }
    
    function restartGame() {
        // Reset game variables
        lives = 3;
        fallCount = 0;
        gameOver = false;
        score = 0;
        boostAmount = 100;
        
        // Reset car position to start
        if (respawnPoint) {
            carPosition.copy(respawnPoint.pos);
            carAngle = respawnPoint.angle;
        } else {
            carPosition.set(0, 5, 0);
            carAngle = 0;
        }
        carVelocity.set(0, 0, 0);
        carSpeed = 0;
        
        // Hide game over screen
        document.getElementById('gameOverScreen').style.display = 'none';
        
        // Update UI
        updateGameUI();
        
        // Spawn collectibles
        spawnCollectibles();
    }
    
    // Collectible items implementation
    function spawnCollectibles() {
        // Remove existing collectibles
        collectibles.forEach(c => {
            if (c.object && c.object.parent) c.object.parent.remove(c.object);
        });
        collectibles = [];
        
        // Only spawn if we have track segments
        if (!trackSegments || trackSegments.length < 2) return;
        
        // Place collectibles along the track
        const numCollectibles = Math.min(20, trackSegments.length / 2);
        
        for (let i = 0; i < numCollectibles; i++) {
            // Get a random track segment (not the first or last)
            const segIdx = Math.floor(Math.random() * (trackSegments.length - 2)) + 1;
            const seg = trackSegments[segIdx];
            
            // Random position along segment
            const t = Math.random();
            const pos = lerpVec3(seg.p1, seg.p2, t);
            pos.y += 3; // float above track
            
            // Create collectible object
            const geometry = new THREE.SphereGeometry(1, 8, 8);
            const material = new THREE.MeshBasicMaterial({
                color: 0xffcc00,
                emissive: 0xffaa00,
                transparent: true,
                opacity: 0.8
            });
            const sphere = new THREE.Mesh(geometry, material);
            sphere.position.copy(pos);
            
            // Add glow effect
            const glowGeo = new THREE.SphereGeometry(1.5, 8, 8);
            const glowMat = new THREE.MeshBasicMaterial({
                color: 0xffcc00,
                transparent: true,
                opacity: 0.4
            });
            const glow = new THREE.Mesh(glowGeo, glowMat);
            sphere.add(glow);
            
            scene.add(sphere);
            
            collectibles.push({
                object: sphere,
                position: pos,
                collected: false,
                value: Math.floor(Math.random() * 50) + 10
            });
        }
        
        collectibleCount = numCollectibles;
    }
    
    function checkCollectibleCollision() {
        if (!carPosition) return;
        
        collectibles.forEach(item => {
            if (!item.collected && item.object) {
                const distance = carPosition.distanceTo(item.position);
                if (distance < 3) {
                    // Collect the item
                    item.collected = true;
                    scene.remove(item.object);
                    
                    // Add to score
                    score += item.value;
                    
                    // Add to boost
                    boostAmount = Math.min(100, boostAmount + 20);
                    
                    // Visual feedback
                    const feedback = document.createElement('div');
                    feedback.textContent = '+' + item.value;
                    feedback.style.position = 'absolute';
                    feedback.style.top = '50%';
                    feedback.style.left = '50%';
                    feedback.style.transform = 'translate(-50%, -50%)';
                    feedback.style.color = '#ffcc00';
                    feedback.style.fontSize = '2em';
                    feedback.style.fontWeight = 'bold';
                    feedback.style.textShadow = '0 0 10px #ff6600';
                    feedback.style.pointerEvents = 'none';
                    feedback.style.transition = 'all 1s';
                    feedback.style.opacity = '1';
                    document.body.appendChild(feedback);
                    
                    // Animate and remove feedback
                    setTimeout(() => {
                        feedback.style.opacity = '0';
                        feedback.style.transform = 'translate(-50%, -100%)';
                        setTimeout(() => document.body.removeChild(feedback), 1000);
                    }, 100);
                    
                    // Update UI
                    updateGameUI();
                }
            }
        });
    }

    // Modified updateCar function with boost and lives
    function updateCar() {
        if (gameOver) return;
        
        // Car controls (arcade style)
        if (keys['ArrowUp']) carSpeed = Math.min(carSpeed + 0.08, carMaxSpeed);
        else carSpeed = Math.max(carSpeed - 0.04, 0);
        if (keys['ArrowLeft']) carAngle += 0.045 * (carSpeed / carMaxSpeed + 0.5);
        if (keys['ArrowRight']) carAngle -= 0.045 * (carSpeed / carMaxSpeed + 0.5);

        // Boost control
        if (keys['ShiftLeft'] && boostAmount > 0) {
            carSpeed = Math.min(carSpeed + 0.15, carMaxSpeed * 1.5);
            boostAmount = Math.max(0, boostAmount - boostDepletionRate);
            updateGameUI();
        } else if (boostAmount < 100) {
            // Recharge boost when not using
            boostAmount = Math.min(100, boostAmount + boostRechargeRate);
            updateGameUI();
        }

        // Update direction
        carDirection.set(Math.sin(carAngle), 0, Math.cos(carAngle)).normalize();

        // Apply forward movement
        carVelocity.x = carDirection.x * carSpeed;
        carVelocity.z = carDirection.z * carSpeed;

        // Gravity
        carVelocity.y += gravity;

        // Move car
        carPosition.add(carVelocity);

        // Track collision: find closest segment below car, and set y if on track
        carOnGround = false;
        let minDist = 99999, groundY = null, groundNormal = new THREE.Vector3(0,1,0);
        let groundAngle = 0;
        let closestSegIdx = -1;
        let closestT = 0;
        for (let i = 0; i < trackSegments.length; i++) {
            let seg = trackSegments[i];
            let segVec = new THREE.Vector3().subVectors(seg.p2, seg.p1);
            let segLen = segVec.length();
            let toCar = new THREE.Vector3().subVectors(carPosition, seg.p1);
            let t = Math.max(0, Math.min(1, segVec.dot(toCar) / (segLen * segLen)));
            let closest = lerpVec3(seg.p1, seg.p2, t);
            let distXZ = Math.sqrt(
                Math.pow(carPosition.x - closest.x, 2) +
                Math.pow(carPosition.z - closest.z, 2)
            );
            if (distXZ < seg.width / 2 + 1) {
                let yOnTrack = closest.y + 1.5;
                let yDiff = carPosition.y - yOnTrack;
                if (yDiff < 2 && yDiff > -2 && Math.abs(yDiff) < minDist) {
                    minDist = Math.abs(yDiff);
                    groundY = yOnTrack;
                    groundNormal = new THREE.Vector3(
                        (seg.p2.y - seg.p1.y) / segLen * segVec.x / segLen,
                        1,
                        (seg.p2.y - seg.p1.y) / segLen * segVec.z / segLen
                    ).normalize();
                    groundAngle = Math.atan2(seg.p2.y - seg.p1.y, segLen);
                    closestSegIdx = i;
                    closestT = t;
                }
            }
        }
        // If on ground, smoothly transition car's y and tilt to match track
        if (groundY !== null && carPosition.y <= groundY + 1.5) {
            carPosition.y += (groundY - carPosition.y) * 0.5;
            carVelocity.y = 0;
            carOnGround = true;
            carVelocity.x *= groundFriction;
            carVelocity.z *= groundFriction;
            car.rotation.x += (groundAngle - car.rotation.x) * 0.2;
            // Update respawn point to last valid position on track
            if (closestSegIdx >= 0) {
                let seg = trackSegments[closestSegIdx];
                let segVec = new THREE.Vector3().subVectors(seg.p2, seg.p1);
                let yaw = Math.atan2(segVec.x, segVec.z);
                respawnPoint = {
                    pos: lerpVec3(seg.p1, seg.p2, closestT).clone(),
                    angle: yaw
                };
            }
        } else {
            carVelocity.x *= friction;
            carVelocity.z *= friction;
            car.rotation.x += (0 - car.rotation.x) * 0.1;
        }

        // Check collectible collisions
        checkCollectibleCollision();
        
        // Respawn if car falls off
        if (carPosition.y < -30 && respawnPoint) {
            fallCount++;
            lives--;
            updateGameUI();
            
            if (lives <= 0) {
                showGameOver();
                return;
            }
            
            carPosition.copy(respawnPoint.pos);
            carAngle = respawnPoint.angle;
            carVelocity.set(0, 0, 0);
            carSpeed = 0;
            car.rotation.x = 0;
        }

        car.position.copy(carPosition);
        car.rotation.y = carAngle;

        // Camera follows car
        let camTarget = carPosition.clone().add(new THREE.Vector3(
            Math.sin(carAngle) * cameraOffset.z,
            cameraOffset.y,
            Math.cos(carAngle) * cameraOffset.z
        ));
        camera.position.lerp(camTarget, 0.18);
        camera.lookAt(car.position);
    }

    // Update animate function for collectibles animation
    function animate() {
        requestAnimationFrame(animate);
        if (car) updateCar();
        
        // Animate collectibles
        collectibles.forEach(item => {
            if (item.object && !item.collected) {
                item.object.rotation.y += 0.02;
                // Float up and down
                item.object.position.y = item.position.y + Math.sin(Date.now() * 0.002) * 0.5;
            }
        });
        
        // Broadcast position at a reasonable rate (10 times per second)
        if (peer && connections.length > 0 && Date.now() % 100 < 20) {
            broadcastPosition();
        }
        
        // Smooth update for each other player
        Object.values(otherPlayers).forEach(p => {
            p.mesh.position.lerp(p.position, 0.2);
            p.mesh.rotation.y = p.angle;
        });
        
        // Remove stale players (disconnected but not caught by close event)
        const now = Date.now();
        Object.keys(otherPlayers).forEach(id => {
            // Increase timeout to 20 seconds for better persistence
            if (now - otherPlayers[id].lastUpdate > 20000) {
                removeOtherPlayerCar(id);
            }
        });
        
        // Update minimap if it exists
        if (document.getElementById('minimap')) {
            updateMinimapMarkers();
        }
        
        renderer.render(scene, camera);
    }

    function clearScene() {
        if (!scene) return;
        for (let i = scene.children.length - 1; i >= 0; i--) {
            const obj = scene.children[i];
            if (obj.isMesh) {
                scene.remove(obj);
                if (obj.geometry) obj.geometry.dispose();
                if (obj.material) obj.material.dispose();
            }
        }
    }

    // --- Multiplayer Logic ---
    let peer = null;
    let connections = [];
    let isHost = false;
    let playerColor = '#' + Math.floor(Math.random()*16777215).toString(16);
    let otherPlayers = {}; // {peerId: {mesh, position, angle, lastUpdate}}
    let playerId = null;
    let playerIndices = {};      // maps peerId → numeric slot
    let nextPlayerIndex = 1;     // start with host = 1

    function joinOrCreateRoom(blockHash) {
        // If already connected to a peer, do nothing
        if (peer) return;

        showLoading(true, 10, "Connecting to room...");
        const hostPeer = new Peer(blockHash);

        hostPeer.on('open', id => {
            // Host: first to enter the room
            isHost = true;
            peer = hostPeer;
            playerId = id;
            playerIndices[id] = 1;
            // Only load block data if not already loaded
            loadBlockData(blockHash).then(() => {
                showLoading(false, 100, "Ready!");
            });
            peer.on('connection', handleConnection);
        });

        hostPeer.on('error', err => {
            // If room exists, join as client
            peer = new Peer();
            peer.on('open', id => {
                playerId = id;
                playerIndices[playerId] = nextPlayerIndex++;
                showLoading(true, 20, "Joining existing room...");
                const conn = peer.connect(blockHash);
                handleConnection(conn);
            });
        });
    }

    function handleConnection(conn) {
        if (!playerIndices[conn.peer]) {
            playerIndices[conn.peer] = nextPlayerIndex++;
        }
        connections.push(conn);

        conn.on('open', () => {
            // Host sends blockData once to new joiner
            if (isHost && storedTransactions.length && blockMetadata) {
                conn.send({
                    type: 'init',
                    blockData: {
                        transactions: storedTransactions,
                        metadata: blockMetadata,
                        blockHash: cachedBlockHash
                    }
                });
            }
            // Everyone shares color & ID
            conn.send({
                type: 'playerInfo',
                playerColor: playerColor,
                playerId: playerId,
                playerIndex: playerIndices[playerId]
            });
            showLoading(false, 100, "Connected!");
            updatePlayersList();
        });

        conn.on('data', data => {
            switch(data.type) {
                case 'init':
                    // Only load block if not already loaded
                    if (data.blockData && (!storedTransactions.length || cachedBlockHash !== data.blockData.blockHash)) {
                        storedTransactions = data.blockData.transactions;
                        blockMetadata = data.blockData.metadata;
                        cachedBlockHash = data.blockData.blockHash;
                        updateBlockInfo(blockMetadata);
                        createDrivingTrack(storedTransactions);
                    }
                    break;
                case 'playerInfo':
                    createOtherPlayerCar(data.playerId, data.playerColor);
                    playerIndices[data.playerId] = data.playerIndex || nextPlayerIndex++;
                    updatePlayersList();
                    break;
                case 'position':
                    updateOtherPlayerPosition(conn.peer, data);
                    break;
            }
        });

        conn.on('close', () => {
            connections = connections.filter(c => c !== conn);
            removeOtherPlayerCar(conn.peer);
            updatePlayersList();
        });
    }

    function updateCarColor(colorHex) {
        if (!car) return;
        // Convert hex string to number for Three.js
        const colorNum = parseInt(colorHex.replace('#', '0x'), 16);
        car.material.color.set(colorNum);
    }

    function updatePlayerCount() {
        document.getElementById('playerCount').textContent = connections.length;
    }

    function handlePeerMessage(peerId, data) {
        switch(data.type) {
            case 'init':
                // If we join and host sends block data, load that block
                if(data.blockHash) {
                    document.getElementById('blockHash').value = data.blockHash;
                    loadBlockData(data.blockHash);
                }
                createOtherPlayerCar(peerId, data.playerColor || '#ff0000');
                break;
                
            case 'position':
                updateOtherPlayerPosition(peerId, data);
                break;
        }
    }

    function createOtherPlayerCar(peerId, colorHex) {
        if (otherPlayers[peerId]) removeOtherPlayerCar(peerId);
        
        let geometry = new THREE.BoxGeometry(3, 2, 5);
        // Convert hex string to number for Three.js
        const colorNum = parseInt(colorHex.replace('#', '0x'), 16);
        let material = new THREE.MeshPhongMaterial({ 
            color: colorNum,
            emissive: new THREE.Color(colorNum).multiplyScalar(0.3) // Make it glow slightly
        });
        let playerCar = new THREE.Mesh(geometry, material);
        scene.add(playerCar);
        
        // Add visible identifier with larger text
        const idx = playerIndices[peerId] || ('?' );
        const playerLabel = createPlayerLabel('P' + idx);
        playerLabel.position.set(0, 4, 0); // Position higher above car
        playerLabel.scale.set(4, 2, 1);    // Make it larger
        playerCar.add(playerLabel);
        
        // Add highlighting effect to make other cars more visible
        const highlightGeo = new THREE.BoxGeometry(3.5, 2.5, 5.5);
        const highlightMat = new THREE.MeshBasicMaterial({
            color: colorNum,
            transparent: true,
            opacity: 0.2,
            wireframe: false
        });
        const highlight = new THREE.Mesh(highlightGeo, highlightMat);
        playerCar.add(highlight);
        
        otherPlayers[peerId] = {
            mesh: playerCar,
            position: new THREE.Vector3(0, 5, 10),
            angle: 0,
            lastUpdate: Date.now(),
            color: colorHex,
            highlight: highlight
        };
        
        // Update player list display
        updatePlayersList();
        // Update minimap markers
        updateMinimapMarkers();
        
        console.log("Created player car for:", peerId);
    }
    
    // Create a floating label above player cars
    function createPlayerLabel(text) {
        const canvas = document.createElement('canvas');
        const context = canvas.getContext('2d');
        canvas.width = 128;
        canvas.height = 64;
        
        // Draw background - using semi-transparent for better visibility
        context.fillStyle = 'rgba(0,0,0,0.7)';
        context.fillRect(0, 0, canvas.width, canvas.height);
        
        // Draw border
        context.strokeStyle = '#ffffff';
        context.lineWidth = 2;
        context.strokeRect(2, 2, canvas.width-4, canvas.height-4);
        
        // Draw text - larger and bold
        context.font = 'bold 28px Arial';
        context.fillStyle = '#ffffff';
        context.textAlign = 'center';
        context.textBaseline = 'middle';
        context.fillText(text, canvas.width/2, canvas.height/2);
        
        // Create sprite
        const texture = new THREE.CanvasTexture(canvas);
        const material = new THREE.SpriteMaterial({ 
            map: texture,
            transparent: true,
            depthTest: false // Always render on top
        });
        const sprite = new THREE.Sprite(material);
        sprite.position.set(0, 3, 0); // Position above car
        sprite.scale.set(3, 1.5, 1);
        
        return sprite;
    }
    
    function updateOtherPlayerPosition(peerId, data) {
        if (!otherPlayers[peerId]) createOtherPlayerCar(peerId, data.color);
        const p = otherPlayers[peerId];
        p.position.set(data.x, data.y, data.z);
        p.angle = data.angle;
        p.lastUpdate = Date.now();
    }
    
    function broadcastPosition() {
        if (!peer || !carPosition) return;
        
        const posData = {
            type: 'position',
            x: carPosition.x,
            y: carPosition.y,
            z: carPosition.z,
            angle: carAngle,
            color: playerColor
        };
        
        connections.forEach(conn => {
            if (conn.open) {
                conn.send(posData);
            }
        });
    }
    
    function updatePlayersList() {
        const list = document.getElementById('playersList');
        list.innerHTML = '<p><strong>Players:</strong></p>';
        
        // Add yourself
        const selfItem = document.createElement('div');
        selfItem.textContent = 'You' + (isHost ? ' (Host)' : '');
        selfItem.style.color = playerColor;
        list.appendChild(selfItem);
        
        // Add other players
        Object.keys(otherPlayers).forEach(id => {
            const playerItem = document.createElement('div');
            playerItem.textContent = id.substring(0, 8) + '...';
            playerItem.style.color = otherPlayers[id].color;
            list.appendChild(playerItem);
        });
    }

    // --- Minimap Implementation ---
    let minimapTrack = [];
    let minimapBounds = {
        minX: 0, maxX: 0,
        minZ: 0, maxZ: 0,
        width: 0, height: 0
    };
    
    function initMinimap() {
        // Create minimap container if it doesn't exist
        const minimap = document.getElementById('minimap');
        minimap.innerHTML = '';
        
        if (trackSegments && trackSegments.length > 0) {
            // Calculate track bounds
            calculateTrackBounds();
            
            // Create track visualization
            drawTrackOnMinimap();
        }
        
        // Create player marker
        const playerMarker = document.createElement('div');
        playerMarker.className = 'playerMarker';
        playerMarker.id = 'playerMarker';
        playerMarker.style.backgroundColor = playerColor;
        minimap.appendChild(playerMarker);
        
        // Update markers immediately
        updateMinimapMarkers();
    }
    
    function calculateTrackBounds() {
        minimapBounds.minX = Infinity;
        minimapBounds.maxX = -Infinity;
        minimapBounds.minZ = Infinity;
        minimapBounds.maxZ = -Infinity;
        
        // Find min/max coordinates of track
        trackSegments.forEach(segment => {
            minimapBounds.minX = Math.min(minimapBounds.minX, segment.p1.x, segment.p2.x);
            minimapBounds.maxX = Math.max(minimapBounds.maxX, segment.p1.x, segment.p2.x);
            minimapBounds.minZ = Math.min(minimapBounds.minZ, segment.p1.z, segment.p2.z);
            minimapBounds.maxZ = Math.max(minimapBounds.maxZ, segment.p1.z, segment.p2.z);
        });
        
        // Add some padding
        const padding = 20;
        minimapBounds.minX -= padding;
        minimapBounds.maxX += padding;
        minimapBounds.minZ -= padding;
        minimapBounds.maxZ += padding;
        
        minimapBounds.width = minimapBounds.maxX - minimapBounds.minX;
        minimapBounds.height = minimapBounds.maxZ - minimapBounds.minZ;
    }
    
    function drawTrackOnMinimap() {
        const minimap = document.getElementById('minimap');
        const minimapWidth = minimap.clientWidth;
        const minimapHeight = minimap.clientHeight;
        
        // Create SVG for track
        const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
        svg.setAttribute('width', '100%');
        svg.setAttribute('height', '100%');
        svg.style.position = 'absolute';
        
        // Draw each track segment
        trackSegments.forEach(segment => {
            // Convert 3D positions to minimap coordinates
            const x1 = mapValue(segment.p1.x, minimapBounds.minX, minimapBounds.maxX, 0, minimapWidth);
            const y1 = mapValue(segment.p1.z, minimapBounds.minZ, minimapBounds.maxZ, 0, minimapHeight);
            const x2 = mapValue(segment.p2.x, minimapBounds.minX, minimapBounds.maxX, 0, minimapWidth);
            const y2 = mapValue(segment.p2.z, minimapBounds.minZ, minimapBounds.maxZ, 0, minimapHeight);
            
            // Create line
            const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
            line.setAttribute('x1', x1);
            line.setAttribute('y1', y1);
            line.setAttribute('x2', x2);
            line.setAttribute('y2', y2);
            line.setAttribute('stroke', '#888');
            line.setAttribute('stroke-width', '2');
            svg.appendChild(line);
        });
        
        minimap.appendChild(svg);
    }
    
    function mapValue(value, inMin, inMax, outMin, outMax) {
        return ((value - inMin) * (outMax - outMin) / (inMax - inMin) + outMin);
    }
    
    function updateMinimapMarkers() {
        if (!minimapBounds || minimapBounds.width === 0) return;
        
        const minimap = document.getElementById('minimap');
        const minimapWidth = minimap.clientWidth;
        const minimapHeight = minimap.clientHeight;
        
        // Update player marker
        const playerMarker = document.getElementById('playerMarker');
        if (playerMarker && carPosition) {
            const playerX = mapValue(carPosition.x, minimapBounds.minX, minimapBounds.maxX, 0, minimapWidth);
            const playerZ = mapValue(carPosition.z, minimapBounds.minZ, minimapBounds.maxZ, 0, minimapHeight);
            playerMarker.style.left = playerX + 'px';
            playerMarker.style.top = playerZ + 'px';
        }
        
        // Update other players' markers
        Object.keys(otherPlayers).forEach(id => {
            const player = otherPlayers[id];
            let marker = document.getElementById('marker-' + id);
            
            if (!marker) {
                marker = document.createElement('div');
                marker.className = 'otherPlayerMarker';
                marker.id = 'marker-' + id;
                marker.style.backgroundColor = player.color;
                minimap.appendChild(marker);
            }
            
            const x = mapValue(player.position.x, minimapBounds.minX, minimapBounds.maxX, 0, minimapWidth);
            const z = mapValue(player.position.z, minimapBounds.minZ, minimapBounds.maxZ, 0, minimapHeight);
            
            marker.style.left = x + 'px';
            marker.style.top = z + 'px';
        });
        
        // Remove markers for disconnected players
        document.querySelectorAll('.otherPlayerMarker').forEach(marker => {
            const id = marker.id.replace('marker-', '');
            if (!otherPlayers[id]) {
                marker.remove();
            }
        });
    }
    
    function removeOtherPlayerCar(peerId) {
        if (otherPlayers[peerId]) {
            scene.remove(otherPlayers[peerId].mesh);
            delete otherPlayers[peerId];
            updatePlayersList();
            
            // Remove from minimap
            const marker = document.getElementById('marker-' + peerId);
            if (marker) marker.remove();
        }
    }
    
    // Add event listeners
    function addGameEventListeners() {
        document.getElementById('restartGame').addEventListener('click', restartGame);
        
        // Prevent scrolling
        window.addEventListener('keydown', e => {
            if(['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'ShiftLeft'].includes(e.code)) {
                e.preventDefault();
            }
            keys[e.code] = true;
        });
    }

    // --- UI and Startup ---
    document.getElementById('blockForm').onsubmit = function(e) {
        e.preventDefault();
        const blockHash = document.getElementById('blockHash').value.trim();
        if (!blockHash) return;
        joinOrCreateRoom(blockHash);
    };

    window.onload = function() {
        initThreeJS();
        animate();
        updateGameUI();
        addGameEventListeners();
    };
    </script>
</body>
</html>
