<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>3DBitmap Driving Game</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>🚗</text></svg>">
    <style>
        html, body {
            height: 100%;
            margin: 0;
            background: #181818;
            color: #fff;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
        }
        #canvasContainer {
            position: absolute;
            top: 0; left: 0; width: 100vw; height: 100vh;
            background: #181818;
            z-index: 1;
        }
        #uiBar {
            position: absolute;
            top: 0; left: 0; width: 100vw;
            background: rgba(24,24,24,0.95);
            color: #ffa94d;
            padding: 8px 16px;
            z-index: 10;
            display: flex;
            align-items: center;
            gap: 18px;
            font-size: 1.1em;
        }
        #blockForm input[type="text"] {
            padding: 6px 10px;
            border-radius: 4px 0 0 4px;
            border: 1px solid #ffa94d;
            outline: none;
            font-size: 1em;
            width: 120px;
        }
        #blockForm button {
            padding: 6px 12px;
            border-radius: 0 4px 4px 0;
            border: none;
            background: #ffa94d;
            color: #181818;
            font-weight: bold;
            cursor: pointer;
            font-size: 1em;
        }
        #blockInfo {
            margin-left: 24px;
            font-size: 0.95em;
            color: #fff;
        }
        #loadingOverlay {
            position: fixed;
            top:0; left:0; width:100vw; height:100vh;
            background: rgba(16,16,24,0.95);
            color: #ffa94d;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 100;
            font-size: 1.3em;
            letter-spacing: 1px;
        }
        #loadingBar {
            width: 240px;
            height: 10px;
            background: #222;
            border-radius: 5px;
            margin-top: 18px;
            overflow: hidden;
        }
        #loadingBarProgress {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg,#f7931a,#ffa94d);
            transition: width 0.2s;
        }
        #instructions {
            position: absolute;
            bottom: 16px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(24,24,24,0.85);
            color: #ffa94d;
            padding: 8px 18px;
            border-radius: 8px;
            font-size: 1em;
            z-index: 10;
            pointer-events: none;
        }
        #minimap {
            position: absolute;
            bottom: 16px;
            right: 16px;
            width: 200px;
            height: 200px;
            background: rgba(0,0,0,0.7);
            border: 2px solid #ffa94d;
            border-radius: 4px;
            overflow: hidden;
            z-index: 10;
        }
        .otherPlayerMarker {
            position: absolute;
            width: 6px;
            height: 6px;
            margin-left: -3px;
            margin-top: -3px;
            border-radius: 50%;
            border: 1px solid #fff;
        }
        .playerMarker {
            position: absolute;
            width: 8px;
            height: 8px;
            margin-left: -4px;
            margin-top: -4px;
            border-radius: 50%;
            border: 1px solid #fff;
            background: #ff0;
        }
        #gameUI {
            position: absolute;
            top: 50px;
            left: 16px;
            background: rgba(24,24,24,0.85);
            color: #ffa94d;
            padding: 8px 18px;
            border-radius: 8px;
            font-size: 1em;
            z-index: 10;
        }
        #gameUI .lives {
            font-size: 1.5em;
            color: #ff3333;
        }
        #gameUI .boost {
            margin-top: 5px;
            height: 8px;
            width: 100px;
            background: rgba(255,255,255,0.2);
            border-radius: 4px;
        }
        #gameUI .boost-bar {
            height: 100%;
            width: 100%;
            background: linear-gradient(90deg, #3366ff, #00ccff);
            border-radius: 4px;
            transition: width 0.2s;
        }
        #gameUI .score {
            margin-top: 5px;
            font-weight: bold;
        }
        #gameOverScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0,0,0,0.85);
            color: #ffa94d;
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 200;
        }
        #gameOverScreen h2 {
            font-size: 3em;
            margin-bottom: 20px;
        }
        #gameOverScreen button {
            padding: 10px 20px;
            border-radius: 5px;
            border: none;
            background: #ffa94d;
            color: #181818;
            font-weight: bold;
            font-size: 1.2em;
            cursor: pointer;
            margin-top: 20px;
        }
        .collectible {
            position: absolute;
            width: 30px;
            height: 30px;
            margin-left: -15px;
            margin-top: -15px;
            border-radius: 50%;
            background: radial-gradient(#ffcc00, #ff6600);
            box-shadow: 0 0 15px #ffcc00;
            animation: pulse 1s infinite alternate;
        }
        @keyframes pulse {
            from { transform: scale(1); }
            to { transform: scale(1.2); }
        }
        #raceControls {
            position: absolute;
            top: 48px;
            right: 16px;
            background: rgba(24,24,24,0.85);
            color: #ffa94d;
            padding: 10px;
            border-radius: 8px;
            z-index: 10;
            width: 220px;
            text-align: center;
        }
        #raceControls button {
            padding: 8px 16px;
            border-radius: 4px;
            border: none;
            background: #ffa94d;
            color: #181818;
            font-weight: bold;
            cursor: pointer;
            margin: 5px;
            font-size: 1em;
        }
        #countdown {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 8em;
            color: #ffa94d;
            font-weight: bold;
            text-shadow: 0 0 20px rgba(255, 169, 77, 0.8);
            z-index: 50;
            display: none;
        }
        .startLine, .finishLine {
            position: absolute;
            left: 0;
            width: 100%;
            height: 5px;
            background: repeating-linear-gradient(
                90deg,
                #fff,
                #fff 20px,
                #000 20px,
                #000 40px
            );
            z-index: 5;
        }
        .startLine {
            background: repeating-linear-gradient(
                90deg,
                #fff,
                #fff 20px,
                #00ff00 20px,
                #00ff00 40px
            );
        }
        .finishLine {
            background: repeating-linear-gradient(
                90deg,
                #fff,
                #fff 20px,
                #ff0000 20px,
                #ff0000 40px
            );
        }
        #nameInputContainer {
            position: fixed;
            top: 16px;
            right: 50%;
            transform: translateX(50%);
            background: rgba(24,24,24,0.85);
            color: #ffa94d;
            padding: 8px 18px;
            border-radius: 8px;
            z-index: 15;
            text-align: center;
        }
        
        #playerName {
            padding: 6px 10px;
            border-radius: 4px;
            border: 1px solid #ffa94d;
            background: #333;
            color: #fff;
            font-size: 1em;
            text-align: center;
            width: 150px;
        }
        
        #jumpIndicator {
            position: absolute;
            bottom: 60px;
            left: 16px;
            background: rgba(24,24,24,0.85);
            color: #00aaff;
            padding: 5px 10px;
            border-radius: 8px;
            font-size: 0.9em;
            z-index: 10;
        }
        
        #jumpIndicator.cooldown {
            color: #777;
        }

        /* Mobile Controls */
        #mobileControls {
            position: fixed;
            bottom: 70px;
            left: 0;
            width: 100%;
            display: none;  /* Hidden by default, shown on mobile */
            z-index: 20;
        }
        
        .control-button {
            width: 60px;
            height: 60px;
            background: rgba(255, 169, 77, 0.7);
            color: #fff;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            font-weight: bold;
            user-select: none;
            border: 2px solid rgba(255, 255, 255, 0.7);
        }
        
        .control-button.active {
            background: rgba(255, 169, 77, 1);
            transform: scale(0.95);
        }
        
        #directionalPad {
            position: fixed;
            bottom: 100px;
            left: 20px;
            display: grid;
            grid-template-columns: 60px 60px 60px;
            grid-template-rows: 60px 60px 60px;
            gap: 5px;
        }
        
        #actionButtons {
            position: fixed;
            bottom: 100px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        .action-row {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
        }
        
        .button-up { grid-column: 2; grid-row: 1; }
        .button-left { grid-column: 1; grid-row: 2; }
        .button-right { grid-column: 3; grid-row: 2; }
        .button-down { grid-column: 2; grid-row: 3; }
        
        /* Shooting related styles */
        .laser-beam {
            position: absolute;
            height: 2px;
            background: linear-gradient(90deg, rgba(255,0,0,0) 0%, rgba(255,0,0,1) 50%, rgba(255,0,0,0) 100%);
            transform-origin: center left;
            z-index: 5;
        }
        
        .hit-effect {
            position: absolute;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(255,0,0,1) 0%, rgba(255,0,0,0) 70%);
            z-index: 5;
            pointer-events: none;
        }
        
        #scorePopup {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #ffcc00;
            font-size: 2.5em;
            font-weight: bold;
            text-shadow: 0 0 10px rgba(255, 204, 0, 0.8);
            z-index: 30;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s, transform 0.7s;
        }
        
        #updateNameButton {
            padding: 6px 10px;
            border-radius: 4px;
            border: 1px solid #ffa94d;
            background: #333;
            color: #fff;
            font-size: 1em;
            margin-left: 5px;
            cursor: pointer;
        }
        
        #nameUpdateSuccess {
            position: absolute;
            top: -20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,255,0,0.7);
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 0.9em;
            opacity: 0;
            transition: opacity 0.5s, top 0.5s;
        }
        
        /* Cooldown indicator for shooting */
        #shootCooldown {
            position: absolute;
            bottom: 60px;
            right: 16px;
            background: rgba(24,24,24,0.85);
            color: #ff3333;
            padding: 5px 10px;
            border-radius: 8px;
            font-size: 0.9em;
            z-index: 10;
        }
        
        #shootCooldown.ready {
            color: #33ff33;
        }
        
        /* Enhanced collectibles */
        .collectible-target {
            position: absolute;
            width: 40px;
            height: 40px;
            margin-left: -20px;
            margin-top: -20px;
            border-radius: 50%;
            border: 2px dashed rgba(255, 204, 0, 0.7);
            animation: rotate 10s linear infinite;
        }
        
        @keyframes rotate {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
        
        /* Available rooms display */
        #availableRooms {
            position: absolute;
            bottom: 240px;
            right: 16px;
            background: rgba(24,24,24,0.85);
            color: #ffa94d;
            padding: 10px;
            border-radius: 8px;
            z-index: 15;
            width: 200px;
            max-height: 300px;
            overflow-y: auto;
        }
        
        .room-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px;
            margin: 5px 0;
            background: rgba(255,255,255,0.1);
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.2s;
        }
        
        .room-item:hover {
            background: rgba(255,255,255,0.2);
        }
        
        .room-players {
            background: rgba(255,169,77,0.3);
            padding: 2px 6px;
            border-radius: 10px;
            font-size: 0.9em;
        }
        
        #refreshRooms {
            width: 100%;
            padding: 5px;
            margin-top: 8px;
            background: #555;
            border: none;
            color: #fff;
            border-radius: 4px;
            cursor: pointer;
        }
        
        #refreshRooms:hover {
            background: #666;
        }
        
        /* Score message */
        .score-message {
            position: absolute;
            color: #ff6600;
            font-weight: bold;
            text-shadow: 0 0 5px rgba(255, 102, 0, 0.5);
            animation: float-up 1.5s forwards;
            pointer-events: none;
        }
        
        @keyframes float-up {
            0% { opacity: 1; transform: translateY(0); }
            100% { opacity: 0; transform: translateY(-50px); }
        }
        
        /* Missing danger indicator */
        #dangerIndicator {
            position: fixed;
            top: 30%;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 0, 0, 0.7);
            color: white;
            font-size: 1.5em;
            font-weight: bold;
            padding: 10px 20px;
            border-radius: 8px;
            z-index: 20;
            display: none;
            text-shadow: 0 0 10px rgba(255, 0, 0, 0.8);
        }
        
        /* FPS counter */
        #fpsCounter {
            position: absolute;
            top: 50px;
            right: 16px;
            background: rgba(0,0,0,0.5);
            color: #00ff00;
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 0.9em;
            z-index: 10;
        }
        
        /* Settings panel */
        #settingsPanel {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(24,24,24,0.95);
            color: #ffa94d;
            padding: 20px;
            border-radius: 8px;
            z-index: 300;
            width: 300px;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            display: none;
        }
        
        #settingsPanel h2 {
            margin-top: 0;
            text-align: center;
        }
        
        .setting-row {
            margin: 10px 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        #settingsPanel button {
            padding: 8px 16px;
            border-radius: 4px;
            border: none;
            background: #ffa94d;
            color: #181818;
            font-weight: bold;
            cursor: pointer;
            margin-top: 15px;
            width: 100%;
        }
        
        #settingsPanel select, #settingsPanel input {
            padding: 5px;
            border-radius: 4px;
            background: #333;
            color: white;
            border: 1px solid #555;
        }
        
        #settingsToggle {
            position: absolute;
            top: 50px;
            right: 250px;
            background: rgba(24,24,24,0.85);
            color: #ffa94d;
            padding: 5px 10px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.9em;
            z-index: 10;
        }
    </style>
</head>
<body>
    <div id="canvasContainer"></div>
    <div id="uiBar">
        <form id="blockForm" style="display:inline-flex;">
            <input type="text" id="blockHash" value="676767" placeholder="Block # or hash">
            <button type="submit">Load</button>
        </form>
        <span id="blockInfo">Block: <span id="blockHeight">-</span> | TX: <span id="txCount">-</span> | BTC: <span id="totalBtc">-</span> | <span id="blockTime">-</span></span>
    </div>
    <div id="instructions">
        <b>Arrow keys</b> to drive. <b>Space</b> to jump. <b>Shift</b> to boost. <b>D</b> to drift. <b>F</b> to shoot. <b>Load a block</b> to generate a new track!
    </div>
    <div id="loadingOverlay" style="display:none;">
        <div id="loadingText">Loading block data...</div>
        <div id="loadingBar"><div id="loadingBarProgress"></div></div>
    </div>
    <div id="minimap"></div>
    <div id="gameUI">
        <div>Lives: <span class="lives">❤️❤️❤️</span></div>
        <div>Boost: <div class="boost"><div class="boost-bar"></div></div></div>
        <div class="score">Score: 0</div>
    </div>
    <div id="gameOverScreen">
        <h2>GAME OVER</h2>
        <div class="final-score">Score: 0</div>
        <button id="restartGame">Try Again</button>
    </div>
    <div id="raceControls" style="display: none;">
        <h3 style="margin-top:0">Race Controls</h3>
        <button id="startRaceButton">Start Race</button>
        <div id="connectedPlayers">
            <p>Connected players: <span id="playerCount">0</span></p>
        </div>
        <div id="playersList" style="max-height: 150px; overflow-y: auto; margin-top: 10px; text-align: left; font-size: 0.9em;"></div>
    </div>
    <div id="countdown"></div>
    <div id="nameInputContainer">
        <label for="playerName">Your Name: </label>
        <input type="text" id="playerName" maxlength="15" placeholder="Enter name">
        <button id="updateNameButton">Update</button>
        <div id="nameUpdateSuccess">Name updated!</div>
    </div>
    <div id="jumpIndicator">Jump Ready</div>
    <div id="shootCooldown" class="ready">Shoot Ready</div>
    <div id="scorePopup"></div>
    <div id="dangerIndicator">DANGER INCOMING!</div>
    <div id="fpsCounter">FPS: 60</div>
    <div id="settingsToggle">⚙️ Settings</div>
    
    <!-- Settings Panel -->
    <div id="settingsPanel">
        <h2>Game Settings</h2>
        <div class="setting-row">
            <label for="qualitySetting">Graphics Quality:</label>
            <select id="qualitySetting">
                <option value="low">Low</option>
                <option value="medium" selected>Medium</option>
                <option value="high">High</option>
            </select>
        </div>
        <div class="setting-row">
            <label for="soundVolume">Sound Volume:</label>
            <input type="range" id="soundVolume" min="0" max="100" value="70">
        </div>
        <div class="setting-row">
            <label for="showFps">Show FPS:</label>
            <input type="checkbox" id="showFps" checked>
        </div>
        <div class="setting-row">
            <label for="difficultyLevel">Difficulty:</label>
            <select id="difficultyLevel">
                <option value="easy">Easy</option>
                <option value="normal" selected>Normal</option>
                <option value="hard">Hard</option>
            </select>
        </div>
        <button id="saveSettings">Save Settings</button>
    </div>
    
    <!-- Available Rooms Display -->
    <div id="availableRooms">
        <h3 style="margin-top:0; text-align:center">Available Rooms</h3>
        <div id="roomsList"></div>
        <button id="refreshRooms">Refresh Rooms</button>
    </div>
    
    <!-- Mobile Controls -->
    <div id="mobileControls">
        <div id="directionalPad">
            <div class="control-button button-up">▲</div>
            <div class="control-button button-left">◀</div>
            <div class="control-button button-right">▶</div>
            <div class="control-button button-down">▼</div>
        </div>
        <div id="actionButtons">
            <div class="action-row">
                <div class="control-button" id="actionBoost">💨</div>
            </div>
            <div class="action-row">
                <div class="control-button" id="actionDrift">↺</div>
                <div class="control-button" id="actionShoot">🔫</div>
            </div>
        </div>
    </div>
    
    <script src="https://unpkg.com/peerjs@1.4.7/dist/peerjs.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
    // --- Minimal Block Data Fetch ---
    let storedTransactions = [];
    let blockMetadata = null;
    let cachedBlockHash = null; // cache the loaded block hash
    let controlsLocked = false; // For race start countdown, prevents movement
    let playerName = "Player";
    let enemies = [];
    let enemySpawnInterval = null;
    
    // Game settings
    let gameSettings = {
        quality: 'medium',
        soundVolume: 70,
        showFps: true,
        difficulty: 'normal'
    };
    
    // Performance monitoring
    let fpsCounter = { frames: 0, lastTime: performance.now() };
    let sharedGeometries = {}; // Cache for reusing geometries
    let sharedMaterials = {}; // Cache for reusing materials
    
    async function loadBlockData(blockHash) {
        // Only fetch and reload if not already loaded
        if (cachedBlockHash === blockHash && storedTransactions.length && blockMetadata) {
            showLoading(false, 100, "Block already loaded");
            return;
        }
        showLoading(true, 0, "Loading block data...");
        try {
            const apiUrl = `https://blockchain.info/rawblock/${blockHash}?cors=true`;
            const response = await fetch(apiUrl);
            if (!response.ok) throw new Error("Block not found");
            showLoading(true, 30, "Parsing block data...");
            const data = await response.json();
            storedTransactions = data.tx || [];
            blockMetadata = {
                height: data.height,
                hash: data.hash,
                time: data.time,
                tx_count: data.tx ? data.tx.length : 0
            };
            showLoading(true, 60, "Generating track...");
            updateBlockInfo(blockMetadata);
            createDrivingTrack(storedTransactions);
            if (respawnPoint) {
                carPosition.copy(respawnPoint.pos);
                carAngle = respawnPoint.angle;
                carVelocity.set(0, 0, 0);
                carSpeed = 0;
                raceFinished = false;
                finishLinePassed = false;
            }
            showLoading(false, 100, "Done");
            cachedBlockHash = blockHash;
        } catch (e) {
            console.error("Error loading block:", e);
            showLoading(true, 100, "Error: " + e.message);
            setTimeout(()=>showLoading(false), 1200);
        }
    }

    async function fetchLatestBlockInfo() {
        showLoading(true, 0, "Fetching latest block info...");
        try {
            // Try multiple API sources with fallbacks
            let response, data;
            
            try {
                // First try with mempool.space API which is more CORS friendly
                response = await fetch('https://mempool.space/api/blocks/tip/height');
                if (response.ok) {
                    const blockHeight = await response.text();
                    document.getElementById('blockHash').value = blockHeight;
                    showLoading(false);
                    return blockHeight;
                }
            } catch (err) {
                console.log("Mempool API failed, trying alternative...");
            }
            
            try {
                // Try blockchain.info directly
                response = await fetch('https://blockchain.info/latestblock');
                if (response.ok) {
                    data = await response.json();
                    document.getElementById('blockHash').value = data.hash || data.height;
                    showLoading(false);
                    return data.hash || data.height;
                }
            } catch (err) {
                console.log("Direct API attempt failed, trying CORS proxy...");
            }
            
            try {
                // Last resort: try with a CORS proxy
                const corsProxy = 'https://corsproxy.io/?';
                response = await fetch(corsProxy + 'https://blockchain.info/latestblock');
                if (response.ok) {
                    data = await response.json();
                    document.getElementById('blockHash').value = data.hash || data.height;
                    showLoading(false);
                    return data.hash || data.height;
                }
            } catch (err) {
                console.log("All API attempts failed...");
            }
            
            // If all fail, use a fallback block
            const fallbackBlock = '783000'; // A recent block height that works
            console.log("Using fallback block:", fallbackBlock);
            document.getElementById('blockHash').value = fallbackBlock;
            showLoading(false);
            return fallbackBlock;
        } catch (e) {
            console.error("Error fetching latest block:", e);
            const fallbackBlock = '783000';
            document.getElementById('blockHash').value = fallbackBlock;
            showLoading(false);
            return fallbackBlock;
        }
    }

    function updateBlockInfo(meta) {
        document.getElementById('blockHeight').textContent = meta.height || '-';
        document.getElementById('txCount').textContent = meta.tx_count || '-';
        let totalBtc = 0;
        if (storedTransactions && storedTransactions.length > 0) {
            storedTransactions.forEach(tx => {
                if (tx.out && Array.isArray(tx.out)) {
                    tx.out.forEach(output => { totalBtc += output.value || 0; });
                }
            });
            totalBtc = (totalBtc / 100000000).toFixed(8);
        }
        document.getElementById('totalBtc').textContent = totalBtc || '-';
        document.getElementById('blockTime').textContent = meta.time ? new Date(meta.time * 1000).toLocaleString() : '-';
    }

    function showLoading(show, percent, text) {
        const overlay = document.getElementById('loadingOverlay');
        overlay.style.display = show ? 'flex' : 'none';
        if (typeof percent === 'number') {
            document.getElementById('loadingBarProgress').style.width = percent + "%";
        }
        if (text) document.getElementById('loadingText').textContent = text;
    }

    // --- Driving Game Logic ---
    let scene, camera, renderer;
    let trackSegments = [];
    let car, carSpeed = 0, carMaxSpeed = 2.5, carSteer = 0, carAngle = 0;
    let carPosition = new THREE.Vector3(0, 5, 0);
    let carVelocity = new THREE.Vector3(0, 0, 0);
    let carDirection = new THREE.Vector3(0, 0, 1);
    let carOnGround = false;
    let cameraOffset = new THREE.Vector3(0, 10, -22);
    let keys = {};
    let gravity = -0.25;
    let friction = 0.98;
    let groundFriction = 0.92;
    let jumpPower = 0.0; // set to >0 for jump support
    let trackWidth = 20; // Increased width for easier driving
    let respawnPoint = null;
    let spatialGrid = {}; // For efficient collision detection

    // Game mechanics variables
    let lives = 3;
    let fallCount = 0;
    let gameOver = false;
    let score = 0;
    let boostAmount = 100;
    let boostRechargeRate = 0.5;
    let boostDepletionRate = 1;
    let collectibles = [];
    let collectibleCount = 0;

    // Race management variables
    let raceActive = false;
    let raceFinished = false;
    let raceStartTime = 0;
    let startLineObj = null;
    let finishLineObj = null;
    let finishLinePassed = false;
    let raceTimes = {}; // Store player finish times

    // Special abilities
    let canJump = true;
    let jumpCooldown = 1500; // milliseconds
    let boostStrength = 1.0;  // Multiplier for boost
    let driftFactor = 0.0;   // For drift mode (0 = no drift)
    
    // Shooting mechanics
    let canShoot = true;
    let shootCooldown = 800; // milliseconds
    let activeLasers = [];
    
    // Rooms storage
    let knownRooms = {};
    
    // Sound effects
    let soundEnabled = false;
    let sounds = {};
    
    // Map value function - missing in original
    function mapValue(value, fromLow, fromHigh, toLow, toHigh) {
        return toLow + (toHigh - toLow) * ((value - fromLow) / (fromHigh - fromLow));
    }

    // Helper for smooth track connection (Catmull-Rom spline)
    function smoothTrackPoints(points) {
        // Adjust hills so there are no step ups/downs: smooth y between points
        // We'll use a moving average to smooth the y values
        let yVals = points.map(p => p.p1.y);
        let smoothYs = [];
        for (let i = 0; i < yVals.length; i++) {
            let sum = 0, count = 0;
            for (let j = -2; j <= 2; j++) {
                if (i + j >= 0 && i + j < yVals.length) {
                    sum += yVals[i + j];
                    count++;
                }
            }
            smoothYs[i] = sum / count;
        }
        // Set all p1.y and p2.y to the smoothed value for both ends of each segment
        for (let i = 0; i < points.length; i++) {
            points[i].p1.y = smoothYs[i];
            if (i < points.length - 1) {
                points[i].p2.y = smoothYs[i + 1];
            } else {
                points[i].p2.y = smoothYs[i];
            }
        }

        // Use CatmullRomCurve3 for smooth interpolation
        let curvePoints = points.map(p => p.p1.clone());
        curvePoints.push(points[points.length - 1].p2.clone());
        let curve = new THREE.CatmullRomCurve3(curvePoints, false, 'catmullrom', 0.5);
        let smooth = [];
        let N = points.length * 8;
        for (let i = 0; i < N; i++) {
            let t1 = i / N;
            let t2 = (i + 1) / N;
            let p1 = curve.getPoint(t1);
            let p2 = curve.getPoint(t2);
            let idx = Math.floor(t1 * points.length);
            let width = points[idx] ? points[idx].width : trackWidth;
            smooth.push({ p1, p2, width });
        }
        return smooth;
    }

    // --- ThreeJS Initialization ---
    function initThreeJS() {
        scene = new THREE.Scene();
        createCosmicBackground();    // ← add cosmic starfield immediately
        
        // Fog for distance effect based on quality setting
        if (gameSettings.quality !== 'low') {
            scene.fog = new THREE.FogExp2(0x000000, 0.01);
        }
        
        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
        camera.position.set(0, 10, -30);
        
        // Renderer with appropriate quality settings
        renderer = new THREE.WebGLRenderer({ 
            antialias: gameSettings.quality !== 'low',
            alpha: true 
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(gameSettings.quality === 'low' ? 1 : window.devicePixelRatio);
        document.getElementById('canvasContainer').appendChild(renderer.domElement);

        // Lighting
        scene.add(new THREE.AmbientLight(0x888888));
        let dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(10, 30, 10);
        scene.add(dirLight);
        
        // Add more lighting for better visuals if quality is high
        if (gameSettings.quality === 'high') {
            // Add hemisphere light for better ambient lighting
            const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.6);
            hemiLight.position.set(0, 50, 0);
            scene.add(hemiLight);
            
            // Add a second directional light for better shadows
            let secondaryLight = new THREE.DirectionalLight(0xccccff, 0.5);
            secondaryLight.position.set(-10, 20, -10);
            scene.add(secondaryLight);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        // Create shared geometries
        initSharedGeometries();
    }
    
    // Add cosmic background starfield
    function createCosmicBackground() {
        // Create a celestial skybox first (large sphere with stars on inside)
        const skyGeometry = new THREE.SphereGeometry(1000, 32, 32);
        const skyMaterial = new THREE.MeshBasicMaterial({
            color: 0x000010,  // Very dark blue instead of black
            side: THREE.BackSide,  // Draw on inside of sphere
        });
        const sky = new THREE.Mesh(skyGeometry, skyMaterial);
        scene.add(sky);

        // Add bright, visible stars (closer and larger)
        addStarLayer(3000, 800, 4, 0xffffff);  // White stars
        addStarLayer(2000, 700, 3, 0xaaccff);  // Blue-tinted stars
        addStarLayer(1000, 600, 5, 0xffddaa);  // Yellow/orange stars
        
        // Add a few glowing nebulae for color and depth
        addNebula(0xff3300, 500, new THREE.Vector3(-400, 200, -400));
        addNebula(0x3366ff, 600, new THREE.Vector3(500, -100, -500));
        
        // Add a large, central galaxy
        addGalaxyDisc(new THREE.Vector3(0, -200, -800), 300, 0x9966ff);
        
        // This nebula function creates a simple colored cloud
        function addNebula(color, size, position) {
            // Create a simple, flat particle system for the nebula
            const nebulaParticles = new THREE.BufferGeometry();
            const particleCount = 100;
            
            const positions = new Float32Array(particleCount * 3);
            const colors = new Float32Array(particleCount * 3);
            const sizes = new Float32Array(particleCount);
            
            const baseColor = new THREE.Color(color);
            
            for (let i = 0; i < particleCount; i++) {
                // Position within a disc shape
                const angle = Math.random() * Math.PI * 2;
                const radius = Math.random() * size;
                const x = Math.cos(angle) * radius;
                const y = (Math.random() - 0.5) * (size * 0.2);
                const z = Math.sin(angle) * radius;
                
                positions[i * 3] = x + position.x;
                positions[i * 3 + 1] = y + position.y;
                positions[i * 3 + 2] = z + position.z;
                
                // Vary the color slightly
                const colorVariance = 0.2;
                colors[i * 3] = baseColor.r * (1 - colorVariance + Math.random() * colorVariance);
                colors[i * 3 + 1] = baseColor.g * (1 - colorVariance + Math.random() * colorVariance);
                colors[i * 3 + 2] = baseColor.b * (1 - colorVariance + Math.random() * colorVariance);
                
                // Vary sizes
                sizes[i] = 30 + Math.random() * 40;
            }
            
            nebulaParticles.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            nebulaParticles.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            nebulaParticles.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
            
            const nebulaMaterial = new THREE.PointsMaterial({
                size: 30,
                vertexColors: true,
                transparent: true,
                opacity: 0.4,
                blending: THREE.AdditiveBlending,
            });
            
            const nebula = new THREE.Points(nebulaParticles, nebulaMaterial);
            scene.add(nebula);
        }
        
        // Create a star layer with specific parameters
        function addStarLayer(count, distance, size, color) {
            const starGeometry = new THREE.BufferGeometry();
            const positions = new Float32Array(count * 3);
            
            for (let i = 0; i < count; i++) {
                // Calculate random position on a sphere
                const theta = Math.random() * 2 * Math.PI;
                const phi = Math.acos(2 * Math.random() - 1);
                const r = distance * (0.9 + Math.random() * 0.1); // Keep them at similar distance
                
                positions[i * 3] = r * Math.sin(phi) * Math.cos(theta);
                positions[i * 3 + 1] = r * Math.sin(phi) * Math.sin(theta);
                positions[i * 3 + 2] = r * Math.cos(phi);
            }
            
            starGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            
            const starMaterial = new THREE.PointsMaterial({
                color: color,
                size: size,
                sizeAttenuation: true
            });
            
            const stars = new THREE.Points(starGeometry, starMaterial);
            scene.add(stars);
        }
        
        // Add a galaxy disc (spiral galaxy)
        function addGalaxyDisc(center, radius, color) {
            const galaxyGeometry = new THREE.BufferGeometry();
            const particleCount = 5000;
            
            const positions = new Float32Array(particleCount * 3);
            const colors = new Float32Array(particleCount * 3);
            const sizes = new Float32Array(particleCount);
            
            const galaxyColor = new THREE.Color(color);
            const coreColor = new THREE.Color(0xffffff);
            
            for (let i = 0; i < particleCount; i++) {
                // Spiral distribution
                const angle = Math.random() * Math.PI * 20; // Many rotations for spiral
                const distance = Math.pow(Math.random(), 0.5) * radius; // More stars toward center
                
                // Add spiral arms by modulating the height based on angle
                const armHeight = 5 * Math.sin(angle * 4) * (distance / radius);
                
                positions[i * 3] = center.x + Math.cos(angle) * distance;
                positions[i * 3 + 1] = center.y + armHeight;
                positions[i * 3 + 2] = center.z + Math.sin(angle) * distance;
                
                // Color varies from core (white) to edge (galaxy color)
                const colorMix = distance / radius;
                const starColor = new THREE.Color().lerpColors(coreColor, galaxyColor, colorMix);
                
                colors[i * 3] = starColor.r;
                colors[i * 3 + 1] = starColor.g;
                colors[i * 3 + 2] = starColor.b;
                
                // Size decreases from core to edge
                sizes[i] = 4 * (1 - (distance / radius) * 0.8);
            }
            
            galaxyGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            galaxyGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            galaxyGeometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
            
            const galaxyMaterial = new THREE.PointsMaterial({
                size: 3,
                vertexColors: true,
                transparent: true,
                opacity: 0.8,
                blending: THREE.AdditiveBlending
            });
            
            const galaxy = new THREE.Points(galaxyGeometry, galaxyMaterial);
            scene.add(galaxy);
            
            // Add bright core
            const coreLight = new THREE.PointLight(0xffffff, 0.2, 500);
            coreLight.position.copy(center);
            scene.add(coreLight);
        }
    }
    
    // Initialize reusable geometries for performance
    function initSharedGeometries() {
        // Car geometry
        sharedGeometries.car = new THREE.BoxGeometry(3, 2, 5);
        
        // Track segment
        sharedGeometries.trackSegment = new THREE.BoxGeometry(1, 2, 1); // Will be scaled
        
        // Collectibles
        sharedGeometries.collectibleTorus = new THREE.TorusGeometry(1, 0.3, 8, 16);
        sharedGeometries.collectibleSphere = new THREE.SphereGeometry(0.7, 8, 8);
        sharedGeometries.collectibleRing = new THREE.RingGeometry(1.2, 1.5, 16);
        
        // Laser
        sharedGeometries.laser = new THREE.CylinderGeometry(0.1, 0.1, 1, 8);
        
        // Hit effect
        sharedGeometries.hitEffect = new THREE.SphereGeometry(2, 8, 8);
        
        // Materials
        sharedMaterials.trackBase = new THREE.MeshPhongMaterial({ color: 0x333333 });
        sharedMaterials.collectibleGlow = new THREE.MeshPhongMaterial({
            color: 0xffcc00,
            emissive: 0xff6600,
            emissiveIntensity: 0.5,
            shininess: 100
        });
        sharedMaterials.collectibleCore = new THREE.MeshPhongMaterial({
            color: 0xff6600,
            emissive: 0xff8800,
            emissiveIntensity: 0.8
        });
        sharedMaterials.laserBeam = new THREE.MeshBasicMaterial({
            color: 0xff0000,
            transparent: true,
            opacity: 0.7
        });
    }

    // Helper for smooth track connection
    function lerpVec3(a, b, t) {
        return new THREE.Vector3(
            a.x + (b.x - a.x) * t,
            a.y + (b.y - a.y) * t,
            a.z + (b.z - a.z) * t
        );
    }

    // Generate flat track with smooth hills and turns
    function createDrivingTrack(transactions) {
        clearScene();
        trackSegments = [];
        spatialGrid = {}; // Reset spatial grid
        let points = [];
        let pos = new THREE.Vector3(0, 0, 0);
        let angleY = 0;

        // 1. Generate points for each segment
        transactions.forEach((tx, i) => {
            let hashVal = parseInt(tx.hash.slice(-2), 16);
            let type = hashVal % 3; // 0: straight, 1: left, 2: right
            let length = 20 + ((tx.out ? tx.out.length : 1) * 5);
            let width = trackWidth;
            // Hill height based on tx value
            let value = tx.out ? tx.out.reduce((acc, cur) => acc + (cur.value || 0), 0) : 0;
            let hill = ((value / 1e8) % 1) * 12 - 6; // -6 to +6

            // Angle based on hash
            if (type === 1) angleY += Math.PI / 12;
            if (type === 2) angleY -= Math.PI / 12;

            // Next point
            let next = new THREE.Vector3(
                pos.x + Math.sin(angleY) * length,
                hill,
                pos.z + Math.cos(angleY) * length
            );
            points.push({ p1: pos.clone(), p2: next.clone(), width, angleY });
            pos = next;
        });

        // Smooth the track (no step up/downs)
        let smoothSegments = smoothTrackPoints(points);
        
        // Create a palette of vibrant colors for the track
        const trackColors = [
            0x3498db, // Blue
            0x2ecc71, // Green
            0xe74c3c, // Red
            0xf39c12, // Orange
            0x9b59b6, // Purple
            0x1abc9c, // Teal
            0xd35400, // Dark Orange
            0x2980b9  // Dark Blue
        ];

        // Create segments with more vibrant colorization
        for (let i = 0; i < smoothSegments.length; i++) {
            let { p1, p2, width } = smoothSegments[i];
            let segLen = p1.distanceTo(p2);
            let mid = lerpVec3(p1, p2, 0.5);
            
            // Use a single shared geometry and scale it
            let boxGeom = sharedGeometries.trackSegment.clone();
            boxGeom.scale(width, 1, segLen);
            
            // Generate color based on segment
            let color;
            
            // Use a gradient with more vibrant colors
            const segmentGroup = Math.floor(i / 3); // Group segments for color patterns
            const colorIndex = segmentGroup % trackColors.length;
            
            // For low quality use vibrant palette too
            color = trackColors[colorIndex];
            
            // Create material with the determined color
            let mat = new THREE.MeshPhongMaterial({ 
                color: color,
                shininess: gameSettings.quality === 'high' ? 60 : 30
            });
            
            let mesh = new THREE.Mesh(boxGeom, mat);

            mesh.position.copy(mid);
            let dx = p2.x - p1.x, dz = p2.z - p1.z;
            mesh.rotation.y = Math.atan2(dx, dz);
            let dy = p2.y - p1.y;
            mesh.rotation.x = Math.atan2(dy, segLen);

            scene.add(mesh);
            
            // Track segment data
            const segmentData = { 
                mesh, 
                p1: p1.clone(), 
                p2: p2.clone(), 
                width, 
                segLen,
                // Add a bounding box for the segment
                bounds: {
                    minX: Math.min(p1.x, p2.x) - width/2,
                    maxX: Math.max(p1.x, p2.x) + width/2,
                    minZ: Math.min(p1.z, p2.z) - width/2,
                    maxZ: Math.max(p1.z, p2.z) + width/2
                }
            };
            trackSegments.push(segmentData);
            
            // Add to spatial grid for collision optimization
            addToSpatialGrid(segmentData);
            
            // Add track details for high quality
            if (gameSettings.quality === 'high' && i % 5 === 0) {
                addTrackDetail(mid, mesh.rotation.y);
            }
        }

        // Place car at start
        createCar(smoothSegments[0].p1, Math.atan2(
            smoothSegments[0].p2.x - smoothSegments[0].p1.x,
            smoothSegments[0].p2.z - smoothSegments[0].p1.z
        ));
        // Store track points for collision
        trackSegments.trackPoints = smoothSegments;
        // Set respawn point to start
        respawnPoint = {
            pos: smoothSegments[0].p1.clone(),
            angle: Math.atan2(
                smoothSegments[0].p2.x - smoothSegments[0].p1.x,
                smoothSegments[0].p2.z - smoothSegments[0].p1.z
            )
        };

        // Re-add other players' meshes so they persist
        Object.values(otherPlayers).forEach(p => {
            if (p.mesh) scene.add(p.mesh);
        });

        // Reset game state for new track
        lives = 3;
        fallCount = 0;
        gameOver = false;
        score = 0;
        boostAmount = 100;
        updateGameUI();

        // Spawn collectibles on the new track
        spawnCollectibles();

        // Create start and finish lines
        createStartAndFinishLines(trackSegments);

        // Reset race state
        raceActive = false;
        raceFinished = false;
        finishLinePassed = false;
        
        // Add sky if quality is high
        if (gameSettings.quality === 'high') {
            createSkybox();
        }
    }
    
    // Add skybox for higher quality settings
    function createSkybox() {
        const skyGeometry = new THREE.BoxGeometry(4000, 4000, 4000);
        const skyMaterials = [
            new THREE.MeshBasicMaterial({ color: 0x2c3e50, side: THREE.BackSide }), // Right
            new THREE.MeshBasicMaterial({ color: 0x2c3e50, side: THREE.BackSide }), // Left
            new THREE.MeshBasicMaterial({ color: 0x1a237e, side: THREE.BackSide }), // Top (darker blue)
            new THREE.MeshBasicMaterial({ color: 0x333333, side: THREE.BackSide }), // Bottom
            new THREE.MeshBasicMaterial({ color: 0x2c3e50, side: THREE.BackSide }), // Front
            new THREE.MeshBasicMaterial({ color: 0x2c3e50, side: THREE.BackSide })  // Back
        ];
        
        const sky = new THREE.Mesh(skyGeometry, skyMaterials);
        scene.add(sky);
        
        // Add stars
        if (gameSettings.quality === 'high') {
            const starsGeometry = new THREE.BufferGeometry();
            const starsMaterial = new THREE.PointsMaterial({
                color: 0xffffff,
                size: 1,
                sizeAttenuation: false
            });
            
            const starsVertices = [];
            for (let i = 0; i < 1000; i++) {
                const x = Math.random() * 2000 - 1000;
                const y = Math.random() * 1000 + 500;
                const z = Math.random() * 2000 - 1000;
                starsVertices.push(x, y, z);
            }
            
            starsGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starsVertices, 3));
            const starField = new THREE.Points(starsGeometry, starsMaterial);
            scene.add(starField);
        }
    }
    
    // Create spatial grid for collision optimization
    function addToSpatialGrid(segment) {
        const cellSize = 50; // Grid cell size
        const minCellX = Math.floor(segment.bounds.minX / cellSize);
        const maxCellX = Math.floor(segment.bounds.maxX / cellSize);
        const minCellZ = Math.floor(segment.bounds.minZ / cellSize);
        const maxCellZ = Math.floor(segment.bounds.maxZ / cellSize);
        
        // Add segment to all cells it intersects with
        for (let x = minCellX; x <= maxCellX; x++) {
            for (let z = minCellZ; z <= maxCellZ; z++) {
                const cellKey = `${x},${z}`;
                if (!spatialGrid[cellKey]) {
                    spatialGrid[cellKey] = [];
                }
                spatialGrid[cellKey].push(segment);
            }
        }
    }
    
    // Get nearby segments using spatial grid
    function getNearbySegments(position, radius = 30) {
        const cellSize = 50;
        const centerCellX = Math.floor(position.x / cellSize);
        const centerCellZ = Math.floor(position.z / cellSize);
        const searchRadius = Math.ceil(radius / cellSize);
        
        let segments = [];
        const checkedSegments = new Set(); // To avoid duplicates
        
        // Check nearby cells
        for (let x = centerCellX - searchRadius; x <= centerCellX + searchRadius; x++) {
            for (let z = centerCellZ - searchRadius; z <= centerCellZ + searchRadius; z++) {
                const cellKey = `${x},${z}`;
                if (spatialGrid[cellKey]) {
                    spatialGrid[cellKey].forEach(segment => {
                        const segmentId = trackSegments.indexOf(segment);
                        if (!checkedSegments.has(segmentId)) {
                            segments.push(segment);
                            checkedSegments.add(segmentId);
                        }
                    });
                }
            }
        }
        
        return segments;
    }

    function createCar(startPos, startAngle) {
        if (car) scene.remove(car);
        let geometry = sharedGeometries.car;
        // Convert player color hex to number
        const colorNum = parseInt(playerColor.replace('#', '0x'), 16);
        let material = new THREE.MeshPhongMaterial({ 
            color: colorNum,
            emissive: new THREE.Color(colorNum).multiplyScalar(0.2) 
        });
        car = new THREE.Mesh(geometry, material);
        car.position.copy(startPos || new THREE.Vector3(0, 5, 0));
        car.rotation.y = startAngle || 0;
        
        // Add self label
        const label = createPlayerLabel('P' + playerIndices[playerId], playerName);
        car.add(label);
        
        // Add car details for higher quality settings
        if (gameSettings.quality !== 'low') {
            // Add wheels
            addCarWheels(car);
            
            // Add headlights
            addCarHeadlights(car);
        }
        
        scene.add(car);
        carSpeed = 0;
        carAngle = startAngle || 0;
        carPosition.copy(car.position);
        carVelocity.set(0, 0, 0);
        carDirection.set(Math.sin(carAngle), 0, Math.cos(carAngle));
        
        // Initialize minimap
        initMinimap();
        
        // Play car spawn sound
        playSound('spawn');
    }
    
    // Add car details for higher quality
    function addCarWheels(carMesh) {
        const wheelGeometry = new THREE.CylinderGeometry(0.7, 0.7, 0.4, 8);
        const wheelMaterial = new THREE.MeshPhongMaterial({ color: 0x111111 });
        
        // Positions for the four wheels
        const wheelPositions = [
            { x: -1.7, y: -0.8, z: 1.8 }, // Front left
            { x: 1.7, y: -0.8, z: 1.8 },  // Front right
            { x: -1.7, y: -0.8, z: -1.8 }, // Rear left
            { x: 1.7, y: -0.8, z: -1.8 }   // Rear right
        ];
        
        wheelPositions.forEach(pos => {
            const wheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
            wheel.position.set(pos.x, pos.y, pos.z);
            wheel.rotation.z = Math.PI / 2; // Rotate to correct orientation
            carMesh.add(wheel);
        });
    }
    
    function addCarHeadlights(carMesh) {
        const lightGeometry = new THREE.SphereGeometry(0.3, 6, 6);
        const lightMaterial = new THREE.MeshPhongMaterial({ 
            color: 0xffffcc,
            emissive: 0xffffcc,
            emissiveIntensity: 0.8
        });
        
        // Add front headlights
        const leftLight = new THREE.Mesh(lightGeometry, lightMaterial);
        leftLight.position.set(-1, 0, 2.4);
        carMesh.add(leftLight);
        
        const rightLight = new THREE.Mesh(lightGeometry, lightMaterial);
        rightLight.position.set(1, 0, 2.4);
        carMesh.add(rightLight);
        
        // Add rear lights
        const rearLightMaterial = new THREE.MeshPhongMaterial({ 
            color: 0xff0000,
            emissive: 0xff0000,
            emissiveIntensity: 0.5
        });
        
        const leftRearLight = new THREE.Mesh(lightGeometry, rearLightMaterial);
        leftRearLight.position.set(-1, 0, -2.4);
        leftRearLight.scale.set(0.7, 0.7, 0.3);
        carMesh.add(leftRearLight);
        
        const rightRearLight = new THREE.Mesh(lightGeometry, rearLightMaterial);
        rightRearLight.position.set(1, 0, -2.4);
        rightRearLight.scale.set(0.7, 0.7, 0.3);
        carMesh.add(rightRearLight);
    }

    // --- Input Handling ---
    function setupControls() {
        // Keyboard controls
        window.addEventListener('keydown', e => { 
            keys[e.code] = true;
            
            // Prevent scrolling and other browser defaults
            if(['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'ShiftLeft', 'Space', 'KeyD', 'KeyF'].includes(e.code)) {
                e.preventDefault();
            }
        });
        
        window.addEventListener('keyup', e => { 
            keys[e.code] = false;
        });
        
        // Mobile controls setup
        setupMobileControls();
    }
    
    // Setup mobile controls
    function setupMobileControls() {
        // Detect mobile device
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        
        if (isMobile) {
            document.getElementById('mobileControls').style.display = 'block';
            
            // Directional pad
            const upButton = document.querySelector('.button-up');
            const leftButton = document.querySelector('.button-left');
            const rightButton = document.querySelector('.button-right');
            const downButton = document.querySelector('.button-down');
            
            // Action buttons
            const boostButton = document.getElementById('actionBoost');
            const jumpButton = document.getElementById('actionJump');
            const driftButton = document.getElementById('actionDrift');
            const shootButton = document.getElementById('actionShoot');
            
            // Setup touch events for directional buttons
            setupTouchControl(upButton, () => { keys['ArrowUp'] = true; }, () => { keys['ArrowUp'] = false; });
            setupTouchControl(leftButton, () => { keys['ArrowLeft'] = true; }, () => { keys['ArrowLeft'] = false; });
            setupTouchControl(rightButton, () => { keys['ArrowRight'] = true; }, () => { keys['ArrowRight'] = false; });
            setupTouchControl(downButton, () => { keys['ArrowDown'] = true; }, () => { keys['ArrowDown'] = false; });
            
            // Setup touch events for action buttons
            setupTouchControl(boostButton, () => { keys['ShiftLeft'] = true; }, () => { keys['ShiftLeft'] = false; });
            setupTouchControl(jumpButton, () => { keys['Space'] = true; }, () => { keys['Space'] = false; });
            
            // Drift button toggles drift mode
            driftButton.addEventListener('touchstart', (e) => {
                e.preventDefault();
                keys['KeyD'] = !keys['KeyD'];
                if (keys['KeyD']) {
                    driftButton.classList.add('active');
                } else {
                    driftButton.classList.remove('active');
                }
                // Handle drift mode toggle
                driftFactor = driftFactor > 0 ? 0 : 0.03;
                const driftMsg = document.createElement('div');
                driftMsg.textContent = driftFactor > 0 ? 'DRIFT MODE: ON' : 'DRIFT MODE: OFF';
                driftMsg.style.position = 'absolute';
                driftMsg.style.bottom = '120px';
                driftMsg.style.left = '50%';
                driftMsg.style.transform = 'translateX(-50%)';
                driftMsg.style.color = '#ff00ff';
                driftMsg.style.fontSize = '1.5em';
                driftMsg.style.fontWeight = 'bold';
                driftMsg.style.zIndex = '15';
                driftMsg.style.background = 'rgba(0,0,0,0.5)';
                driftMsg.style.padding = '5px 15px';
                driftMsg.style.borderRadius = '10px';
                document.body.appendChild(driftMsg);
                setTimeout(() => document.body.removeChild(driftMsg), 1500);
            });
            
            // Shoot button
            setupTouchControl(shootButton, () => { 
                if (canShoot) {
                    shootLaser();
                    canShoot = false;
                    
                    // Update cooldown indicator
                    const cooldownIndicator = document.getElementById('shootCooldown');
                    cooldownIndicator.textContent = 'Reloading...';
                    cooldownIndicator.classList.remove('ready');
                    
                    // Reset cooldown
                    setTimeout(() => {
                        canShoot = true;
                        cooldownIndicator.textContent = 'Shoot Ready';
                        cooldownIndicator.classList.add('ready');
                    }, shootCooldown);
                }
            });
        }
    }
    
    // Helper for mobile touch controls
    function setupTouchControl(element, startCallback, endCallback) {
        element.addEventListener('touchstart', (e) => {
            e.preventDefault();
            element.classList.add('active');
            if (startCallback) startCallback();
        });
        
        element.addEventListener('touchend', (e) => {
            e.preventDefault();
            element.classList.remove('active');
            if (endCallback) endCallback();
        });
        
        element.addEventListener('touchcancel', (e) => {
            e.preventDefault();
            element.classList.remove('active');
            if (endCallback) endCallback();
        });
    }

    function updateGameUI() {
        // Update lives display
        const livesDisplay = document.querySelector('#gameUI .lives');
        const hearts = '❤️'.repeat(lives);
        livesDisplay.textContent = hearts;
        
        // Update boost bar
        const boostBar = document.querySelector('#gameUI .boost-bar');
        boostBar.style.width = boostAmount + '%';
        
        // Update score
        document.querySelector('#gameUI .score').textContent = 'Score: ' + score;
    }
    
    function showGameOver() {
        document.getElementById('gameOverScreen').style.display = 'flex';
        document.querySelector('#gameOverScreen .final-score').textContent = 'Score: ' + score;
        gameOver = true;
        playSound('gameOver');
    }
    
    function restartGame() {
        // Reset game variables
        lives = 3;
        fallCount = 0;
        gameOver = false;
        score = 0;
        boostAmount = 100;
        
        // Reset car position to start
        if (respawnPoint) {
            carPosition.copy(respawnPoint.pos);
            carAngle = respawnPoint.angle;
        } else {
            carPosition.set(0, 5, 0);
            carAngle = 0;
        }
        carVelocity.set(0, 0, 0);
        carSpeed = 0;
        
        // Hide game over screen
        document.getElementById('gameOverScreen').style.display = 'none';
        
        // Update UI
        updateGameUI();
        
        // Spawn collectibles
        spawnCollectibles();
        
        // Play sound
        playSound('restart');
    }
    
    // Collectible items implementation
    function spawnCollectibles() {
        // Remove existing collectibles
        collectibles.forEach(c => {
            if (c.object && c.object.parent) c.object.parent.remove(c.object);
        });
        collectibles = [];
        
        // Only spawn if we have track segments
        if (!trackSegments || trackSegments.length < 2) return;
        
        // Place collectibles along the track - more collectibles now
        const numCollectibles = Math.min(30, trackSegments.length / 2);
        
        for (let i = 0; i < numCollectibles; i++) {
            // Get a random track segment (not the first or last)
            const segIdx = Math.floor(Math.random() * (trackSegments.length - 2)) + 1;
            const seg = trackSegments[segIdx];
            
            // Random position along segment
            const t = Math.random();
            const pos = lerpVec3(seg.p1, seg.p2, t);
            pos.y += 3; // float above track
            
            // Create enhanced collectible object using shared geometries
            const torus = new THREE.Mesh(
                sharedGeometries.collectibleTorus,
                sharedMaterials.collectibleGlow.clone() // Clone to allow individual animations
            );
            
            // Add rotating elements
            const innerSphere = new THREE.Mesh(
                sharedGeometries.collectibleSphere,
                sharedMaterials.collectibleCore.clone()
            );
            torus.add(innerSphere);
            
            // Create outer ring
            const ring = new THREE.Mesh(
                sharedGeometries.collectibleRing,
                new THREE.MeshBasicMaterial({
                    color: 0xffcc00,
                    transparent: true,
                    opacity: 0.6,
                    side: THREE.DoubleSide
                })
            );
            ring.rotation.x = Math.PI / 2;
            torus.add(ring);
            
            // Position and add to scene
            torus.position.copy(pos);
            scene.add(torus);
            
            // Store collectible data
            collectibles.push({
                object: torus,
                position: pos,
                collected: false,
                value: Math.floor(Math.random() * 80) + 20, // Higher values
                rotation: {
                    x: Math.random() * 0.05 - 0.025,
                    y: Math.random() * 0.05 - 0.025,
                    z: Math.random() * 0.05 - 0.025
                }
            });
        }
        
        collectibleCount = numCollectibles;
    }
    
    function checkCollectibleCollision() {
        if (!carPosition) return;
        
        collectibles.forEach(item => {
            if (!item.collected && item.object) {
                const distance = carPosition.distanceTo(item.position);
                if (distance < 3) {
                    // Collect the item
                    item.collected = true;
                    scene.remove(item.object);
                    
                    // Add to score
                    score += item.value;
                    
                    // Add to boost
                    boostAmount = Math.min(100, boostAmount + 20);
                    
                    // Visual feedback
                    showScorePopup(item.value);
                    
                    // Update UI
                    updateGameUI();
                    
                    // Play sound
                    playSound('collect');
                }
            }
        });
    }
    
    function showScorePopup(value) {
        const scorePopup = document.getElementById('scorePopup');
        scorePopup.textContent = '+' + value;
        scorePopup.style.opacity = '1';
        scorePopup.style.transform = 'translate(-50%, -50%) scale(1.3)';
        
        setTimeout(() => {
            scorePopup.style.opacity = '0';
            scorePopup.style.transform = 'translate(-50%, -80%) scale(1)';
        }, 100);
    }

    function updateCar() {
        if (gameOver) return;
        
        // Only allow controls when not locked
        if (!controlsLocked) {
            // Car controls (arcade style)
            if (keys['ArrowUp']) carSpeed = Math.min(carSpeed + 0.08, carMaxSpeed);
            else carSpeed = Math.max(carSpeed - 0.04, 0);
            if (keys['ArrowLeft']) carAngle += (0.045 + driftFactor) * (carSpeed / carMaxSpeed + 0.5);
            if (keys['ArrowRight']) carAngle -= (0.045 + driftFactor) * (carSpeed / carMaxSpeed + 0.5);

            // Jump control - Space bar
            if (keys['Space'] && canJump && carOnGround) {
                carVelocity.y = 6; // Jump power
                carOnGround = false;
                canJump = false;
                
                // Visual feedback for jump
                const jumpFeedback = document.createElement('div');
                jumpFeedback.textContent = 'JUMP!';
                jumpFeedback.style.position = 'absolute';
                jumpFeedback.style.top = '40%';
                jumpFeedback.style.left = '50%';
                jumpFeedback.style.transform = 'translate(-50%, -50%)';
                jumpFeedback.style.color = '#00aaff';
                jumpFeedback.style.fontSize = '2em';
                jumpFeedback.style.fontWeight = 'bold';
                jumpFeedback.style.zIndex = '15';
                document.body.appendChild(jumpFeedback);
                
                // Play jump sound
                playSound('jump');
                
                setTimeout(() => {
                    document.body.removeChild(jumpFeedback);
                    // Reset jump cooldown
                    setTimeout(() => { canJump = true; }, jumpCooldown);
                }, 500);
            }

            // Boost control with enhanced strength
            if (keys['ShiftLeft'] && boostAmount > 0) {
                carSpeed = Math.min(carSpeed + 0.15 * boostStrength, carMaxSpeed * 1.5 * boostStrength);
                boostAmount = Math.max(0, boostAmount - boostDepletionRate);
                updateGameUI();
                
                // Add boost particle effect
                if (gameSettings.quality !== 'low' && carSpeed > carMaxSpeed) {
                    createBoostEffect();
                }
            } else if (boostAmount < 100) {
                // Recharge boost when not using
                boostAmount = Math.min(100, boostAmount + boostRechargeRate);
                updateGameUI();
            }
            
            // Drift mode toggle with 'D' key
            if (keys['KeyD'] && !keys.KeyD_previous) {
                driftFactor = driftFactor > 0 ? 0 : 0.03;
                const driftMsg = document.createElement('div');
                driftMsg.textContent = driftFactor > 0 ? 'DRIFT MODE: ON' : 'DRIFT MODE: OFF';
                driftMsg.style.position = 'absolute';
                driftMsg.style.bottom = '120px';
                driftMsg.style.left = '50%';
                driftMsg.style.transform = 'translateX(-50%)';
                driftMsg.style.color = '#ff00ff';
                driftMsg.style.fontSize = '1.5em';
                driftMsg.style.fontWeight = 'bold';
                driftMsg.style.zIndex = '15';
                driftMsg.style.background = 'rgba(0,0,0,0.5)';
                driftMsg.style.padding = '5px 15px';
                driftMsg.style.borderRadius = '10px';
                document.body.appendChild(driftMsg);
                
                // Play drift sound
                playSound('drift');
                
                setTimeout(() => document.body.removeChild(driftMsg), 1500);
            }
            keys.KeyD_previous = keys['KeyD'];
            
            // Shooting mechanic with 'F' key
            if (keys['KeyF'] && canShoot) {
                shootLaser();
                canShoot = false;
                
                // Update cooldown indicator
                const cooldownIndicator = document.getElementById('shootCooldown');
                cooldownIndicator.textContent = 'Reloading...';
                cooldownIndicator.classList.remove('ready');
                
                // Reset cooldown
                setTimeout(() => {
                    canShoot = true;
                    cooldownIndicator.textContent = 'Shoot Ready';
                    cooldownIndicator.classList.add('ready');
                }, shootCooldown);
            }
        } else {
            // When controls are locked, slow down
            carSpeed = Math.max(carSpeed - 0.08, 0);
        }

        // Update direction
        carDirection.set(Math.sin(carAngle), 0, Math.cos(carAngle)).normalize();

        // Apply forward movement
        carVelocity.x = carDirection.x * carSpeed;
        carVelocity.z = carDirection.z * carSpeed;

        // Gravity
        carVelocity.y += gravity;

        // Move car
        carPosition.add(carVelocity);

        // Track collision: optimized to only check nearby segments
        carOnGround = false;
        let minDist = 99999, groundY = null, groundNormal = new THREE.Vector3(0,1,0);
        let groundAngle = 0;
        let closestSegIdx = -1;
        let closestT = 0;
        
        // Get nearby segments using spatial grid
        const nearbySegments = getNearbySegments(carPosition);
        
        for (let i = 0; i < nearbySegments.length; i++) {
            let seg = nearbySegments[i];
            let segVec = new THREE.Vector3().subVectors(seg.p2, seg.p1);
            let segLen = segVec.length();
            let toCar = new THREE.Vector3().subVectors(carPosition, seg.p1);
            let t = Math.max(0, Math.min(1, segVec.dot(toCar) / (segLen * segLen)));
            let closest = lerpVec3(seg.p1, seg.p2, t);
            let distXZ = Math.sqrt(
                Math.pow(carPosition.x - closest.x, 2) +
                Math.pow(carPosition.z - closest.z, 2)
            );
            if (distXZ < seg.width / 2 + 1) {
                let yOnTrack = closest.y + 1.5;
                let yDiff = carPosition.y - yOnTrack;
                
                // Modified condition to prevent falling through track when landing
                // Check if car is above track and moving downward
                if (yDiff > -2 && Math.abs(yDiff) < minDist) {
                    minDist = Math.abs(yDiff);
                    groundY = yOnTrack;
                    groundNormal = new THREE.Vector3(
                        (seg.p2.y - seg.p1.y) / segLen * segVec.x / segLen,
                        1,
                        (seg.p2.y - seg.p1.y) / segLen * segVec.z / segLen
                    ).normalize();
                    groundAngle = Math.atan2(seg.p2.y - seg.p1.y, segLen);
                    closestSegIdx = trackSegments.indexOf(seg);
                    closestT = t;
                }
            }
        }
        
        // If on ground, smoothly transition car's y and tilt to match track
        if (groundY !== null && (carPosition.y <= groundY + 0.5 || (carPosition.y <= groundY + 3 && carVelocity.y < 0))) {
            // Stop downward movement if we're landing
            if (carVelocity.y < 0) {
                carPosition.y = groundY;
                carVelocity.y = 0;
                
                // Add landing effect if falling from height
                if (carVelocity.y < -5 && gameSettings.quality !== 'low') {
                    createLandingEffect();
                }
            } else {
                // Normal ground following behavior
                carPosition.y += (groundY - carPosition.y) * 0.5;
            }
            carOnGround = true;
            carVelocity.x *= groundFriction;
            carVelocity.z *= groundFriction;
            car.rotation.x += (groundAngle - car.rotation.x) * 0.2;
            
            // Update respawn point to last valid position on track
            if (closestSegIdx >= 0) {
                let seg = trackSegments[closestSegIdx];
                let segVec = new THREE.Vector3().subVectors(seg.p2, seg.p1);
                let yaw = Math.atan2(segVec.x, segVec.z);
                respawnPoint = {
                    pos: lerpVec3(seg.p1, seg.p2, closestT).clone(),
                    angle: yaw
                };
            }
        } else {
            carVelocity.x *= friction;
            carVelocity.z *= friction;
            car.rotation.x += (0 - car.rotation.x) * 0.1;
        }

        // Check collectible collisions
        checkCollectibleCollision();
        
        // Check finish line
        if (raceActive && !raceFinished) {
            checkFinishLine();
        }
        
        // Check if active lasers hit anything
        updateLasers();
        
        // Respawn if car falls off
        if (carPosition.y < -30 && respawnPoint) {
            fallCount++;
            lives--;
            updateGameUI();
            
            // Play fall sound
            playSound('fall');
            
            if (lives <= 0) {
                showGameOver();
                return;
            }
            
            carPosition.copy(respawnPoint.pos);
            carAngle = respawnPoint.angle;
            carVelocity.set(0, 0, 0);
            carSpeed = 0;
            car.rotation.x = 0;
        }

        car.position.copy(carPosition);
        car.rotation.y = carAngle;

        // Camera follows car with improved smoothing
        let idealOffset = new THREE.Vector3(
            Math.sin(carAngle) * cameraOffset.z,
            cameraOffset.y,
            Math.cos(carAngle) * cameraOffset.z
        );
        
        // Adjust camera height based on car speed for dynamic effect
        idealOffset.y += Math.min(carSpeed * 0.5, 5);
        
        let camTarget = carPosition.clone().add(idealOffset);
        
        // Smoother camera follow with easing
        camera.position.lerp(camTarget, 0.05 + (carSpeed / carMaxSpeed) * 0.13);
        
        // Look ahead more at higher speeds
        const lookAheadFactor = 5 + (carSpeed / carMaxSpeed) * 15;
        const lookTarget = carPosition.clone().add(
            new THREE.Vector3(
                Math.sin(carAngle) * lookAheadFactor,
                0,
                Math.cos(carAngle) * lookAheadFactor
            )
        );
        camera.lookAt(lookTarget);
    }
    
    // Visual effects for boost
    function createBoostEffect() {
        if (!car) return;
        
        // Create particles behind the car
        const particleCount = 3;
        
        for (let i = 0; i < particleCount; i++) {
            // Calculate particle position behind car
            const offset = new THREE.Vector3(
                Math.random() * 2 - 1,  // Random X offset
                Math.random() * 0.5,    // Random Y offset
                -3 - Math.random() * 2  // Behind car (-Z)
            );
            
            // Apply car's rotation to the offset
            offset.applyAxisAngle(new THREE.Vector3(0, 1, 0), carAngle);
            
            // Position behind car
            const position = carPosition.clone().add(offset);
            
            // Create particle
            const particle = document.createElement('div');
            particle.className = 'hit-effect';
            particle.style.position = 'absolute';
            
            // Convert 3D position to screen coordinates
            const vector = position.clone();
            vector.project(camera);
            
            const x = (vector.x * 0.5 + 0.5) * window.innerWidth;
            const y = (-vector.y * 0.5 + 0.5) * window.innerHeight;
            
            particle.style.left = x + 'px';
            particle.style.top = y + 'px';
            particle.style.background = 'radial-gradient(circle, rgba(0,100,255,0.7) 0%, rgba(0,0,255,0) 70%)';
            particle.style.width = '30px';
            particle.style.height = '30px';
            document.body.appendChild(particle);
            
            // Animate and remove
            setTimeout(() => {
                particle.style.opacity = '0';
                setTimeout(() => {
                    document.body.removeChild(particle);
                }, 300);
            }, 100);
        }
    }
    
    // Create landing effect when falling from height
    function createLandingEffect() {
        // Create dust particles in 3D
        const particleCount = 10;
        const particles = new THREE.Group();
        
        for (let i = 0; i < particleCount; i++) {
            const size = 0.3 + Math.random() * 0.4;
            const geo = new THREE.SphereGeometry(size, 4, 4);
            const mat = new THREE.MeshBasicMaterial({
                color: 0xdddddd,
                transparent: true,
                opacity: 0.6
            });
            const particle = new THREE.Mesh(geo, mat);
            
            // Random position around car
            const theta = Math.random() * Math.PI * 2;
            const radius = 2 + Math.random() * 2;
            
            particle.position.x = carPosition.x + Math.cos(theta) * radius;
            particle.position.y = carPosition.y;
            particle.position.z = carPosition.z + Math.sin(theta) * radius;
            
            // Random velocity
            particle.userData.velocity = new THREE.Vector3(
                Math.random() * 0.2 - 0.1,
                0.1 + Math.random() * 0.2,
                Math.random() * 0.2 - 0.1
            );
            
            particle.userData.rotationSpeed = {
                x: Math.random() * 0.1,
                y: Math.random() * 0.1,
                z: Math.random() * 0.1
            };
            
            particles.add(particle);
        }
        
        scene.add(particles);
        
        // Animate particles
        const animateParticles = () => {
            particles.children.forEach(p => {
                p.position.add(p.userData.velocity);
                p.userData.velocity.y -= 0.01; // Gravity
                
                p.rotation.x += p.userData.rotationSpeed.x;
                p.rotation.y += p.userData.rotationSpeed.y;
                p.rotation.z += p.userData.rotationSpeed.z;
                
                p.material.opacity -= 0.02;
                if (p.material.opacity <= 0) {
                    particles.remove(p);
                }
            });
            
            if (particles.children.length > 0) {
                requestAnimationFrame(animateParticles);
            } else {
                scene.remove(particles);
            }
        };
        
        animateParticles();
        
        // Play landing sound
        playSound('land');
    }
    
    // Shooting mechanics
    function shootLaser() {
        if (!car || !carPosition) return;
        
        // Create visual laser beam effect
        const laserLength = 100; // How far the laser shoots
        const laserDirection = new THREE.Vector3(
            Math.sin(carAngle),
            Math.sin(car.rotation.x) * 0.5, // Add some elevation based on car tilt
            Math.cos(carAngle)
        ).normalize();
        
        // Calculate endpoint
        const endPoint = carPosition.clone().add(laserDirection.clone().multiplyScalar(laserLength));
        
        // Create laser beam in three.js - use shared geometry
        const laserGeometry = sharedGeometries.laser.clone();
        laserGeometry.scale(1, laserLength, 1);
        
        const laserMaterial = sharedMaterials.laserBeam.clone();
        const laser = new THREE.Mesh(laserGeometry, laserMaterial);
        
        // Position and rotate
        laser.position.copy(carPosition);
        laser.position.y += 1; // Adjust to fire from top of car
        
        // Orient the laser to point in the direction
        const yAxis = new THREE.Vector3(0, 1, 0);
        const zAxis = new THREE.Vector3(0, 0, 1);
        const alignAxis = new THREE.Vector3();
        
        alignAxis.crossVectors(zAxis, laserDirection).normalize();
        const radians = Math.acos(zAxis.dot(laserDirection));
        
        laser.quaternion.setFromAxisAngle(alignAxis, radians);
        
        // Move to middle of the beam
        laser.translateOnAxis(zAxis, laserLength / 2);
        
        scene.add(laser);
        
        // Store active laser
        const newLaser = {
            mesh: laser,
            origin: carPosition.clone(),
            direction: laserDirection,
            length: laserLength,
            endPoint: endPoint,
            createdAt: Date.now()
        };
        
        activeLasers.push(newLaser);
        
        // Play sound effect
        playSound('shoot');
        
        // Add visual feedback
        const muzzleFlash = document.createElement('div');
        muzzleFlash.style.position = 'absolute';
        muzzleFlash.style.width = '100px';
        muzzleFlash.style.height = '100px';
        muzzleFlash.style.background = 'radial-gradient(circle, rgba(255,128,0,0.7) 0%, rgba(255,0,0,0) 70%)';
        muzzleFlash.style.top = '50%';
        muzzleFlash.style.left = '50%';
        muzzleFlash.style.transform = 'translate(-50%, -50%)';
        muzzleFlash.style.zIndex = '5';
        muzzleFlash.style.pointerEvents = 'none';
        document.body.appendChild(muzzleFlash);
        
        setTimeout(() => {
            document.body.removeChild(muzzleFlash);
        }, 100);
        
        // Ray casting to check for hits
        checkLaserHits(newLaser);
    }
    
    function checkLaserHits(laser) {
        // Check hits on other players
        Object.keys(otherPlayers).forEach(playerId => {
            const player = otherPlayers[playerId];
            
            // Calculate closest point on the ray to the target
            const targetPos = player.position;
            const rayOrigin = laser.origin;
            const rayDirection = laser.direction;
            
            // Calculate vector from ray origin to target
            const toTarget = new THREE.Vector3().subVectors(targetPos, rayOrigin);
            
            // Project vector onto ray direction
            const projection = toTarget.dot(rayDirection);
            
            // Calculate closest point on ray
            const closestPoint = new THREE.Vector3().addVectors(
                rayOrigin,
                rayDirection.clone().multiplyScalar(Math.max(0, Math.min(laser.length, projection)))
            );
            
            // Check distance from closest point to target
            const distance = closestPoint.distanceTo(targetPos);
            
            // If distance is less than hit radius, it's a hit
            if (distance < 2.5) {
                // Hit effect
                createHitEffect(targetPos);
                
                // Score for hitting another player
                addScore(50, targetPos);
                
                // Notify player of hit
                broadcastHit(playerId);
            }
        });
        
        // Check hits on enemies
        enemies.forEach(enemy => {
            if (!enemy.active) return;
            
            const targetPos = enemy.position;
            const rayOrigin = laser.origin;
            const rayDirection = laser.direction;
            
            // Calculate vector from ray origin to target
            const toTarget = new THREE.Vector3().subVectors(targetPos, rayOrigin);
            
            // Project vector onto ray direction
            const projection = toTarget.dot(rayDirection);
            
            // Calculate closest point on ray
            const closestPoint = new THREE.Vector3().addVectors(
                rayOrigin,
                rayDirection.clone().multiplyScalar(Math.max(0, Math.min(laser.length, projection)))
            );
            
            // Check distance from closest point to target
            const distance = closestPoint.distanceTo(targetPos);
            
            // If distance is less than hit radius, it's a hit
            if (distance < 3) {
                // Hit effect
                createHitEffect(targetPos);
                
                // Disable enemy
                enemy.active = false;
                
                // Score for hitting an enemy
                addScore(100, targetPos);
                
                // Play hit sound
                playSound('hit');
                
                // Remove enemy
                setTimeout(() => {
                    if (enemy.mesh && enemy.mesh.parent) {
                        scene.remove(enemy.mesh);
                        enemies.splice(enemies.indexOf(enemy), 1);
                    }
                }, 500);
            }
        });
        
        // Check hits on collectibles (for shooting bonus)
        collectibles.forEach(item => {
            if (item.collected) return;
            
            const targetPos = item.position;
            const rayOrigin = laser.origin;
            const rayDirection = laser.direction;
            
            // Calculate vector from ray origin to target
            const toTarget = new THREE.Vector3().subVectors(targetPos, rayOrigin);
            
            // Project vector onto ray direction
            const projection = toTarget.dot(rayDirection);
            
            // Calculate closest point on ray
            const closestPoint = new THREE.Vector3().addVectors(
                rayOrigin,
                rayDirection.clone().multiplyScalar(Math.max(0, Math.min(laser.length, projection)))
            );
            
            // Check distance from closest point to target
            const distance = closestPoint.distanceTo(targetPos);
            
            // If distance is less than hit radius, it's a hit
            if (distance < 2) {
                // Hit effect
                createHitEffect(targetPos);
                
                // Collect and add bonus points (double the value)
                item.collected = true;
                scene.remove(item.object);
                
                // Double score for shooting collectibles
                addScore(item.value * 2, targetPos);
                
                // Play bonus sound
                playSound('bonus');
            }
        });
    }
    
    function createHitEffect(position) {
        // Visual hit effect using shared geometry
        const hitMaterial = new THREE.MeshBasicMaterial({
            color: 0xff0000,
            transparent: true,
            opacity: 0.7
        });
        const hitEffect = new THREE.Mesh(sharedGeometries.hitEffect, hitMaterial);
        hitEffect.position.copy(position);
        scene.add(hitEffect);
        
        // Animate and remove
        let scale = 1;
        const expandEffect = setInterval(() => {
            scale += 0.2;
            hitEffect.scale.set(scale, scale, scale);
            hitMaterial.opacity -= 0.07;
            
            if (hitMaterial.opacity <= 0) {
                clearInterval(expandEffect);
                scene.remove(hitEffect);
            }
        }, 50);
    }
    
    function updateLasers() {
        // Remove expired lasers
        const now = Date.now();
        for (let i = activeLasers.length - 1; i >= 0; i--) {
            const laser = activeLasers[i];
            
            // Remove lasers after 500ms
            if (now - laser.createdAt > 500) {
                scene.remove(laser.mesh);
                activeLasers.splice(i, 1);
            }
        }
    }
    
    function addScore(points, position) {
        score += points;
        updateGameUI();
        
        // Show floating score text at 3D position
        if (position) {
            // Project 3D position to 2D screen coordinates
            const vector = position.clone();
            vector.project(camera);
            
            const x = (vector.x * 0.5 + 0.5) * window.innerWidth;
            const y = (vector.y * -0.5 + 0.5) * window.innerHeight;
            
            const scoreMsg = document.createElement('div');
            scoreMsg.textContent = '+' + points;
            scoreMsg.className = 'score-message';
            scoreMsg.style.left = x + 'px';
            scoreMsg.style.top = y + 'px';
            scoreMsg.style.fontSize = '1.5em';
            document.body.appendChild(scoreMsg);
            
            // Remove after animation completes
            setTimeout(() => {
                document.body.removeChild(scoreMsg);
            }, 1500);
        }
    }
    
    function broadcastHit(targetPlayerId) {
        if (!peer || !connections.length) return;
        
        connections.forEach(conn => {
            if (conn.open && conn.peer === targetPlayerId) {
                conn.send({
                    type: 'playerHit',
                    fromPlayerId: playerId,
                    hitTime: Date.now()
                });
            }
        });
    }

    // Update animate function for collectibles animation
    function animate() {
        requestAnimationFrame(animate);
        
        // Update FPS counter
        updateFPS();
        
        if (car) updateCar();
        
        // Update enemies
        updateEnemies();
        
        // Animate collectibles with improved animation
        collectibles.forEach(item => {
            if (item.object && !item.collected) {
                // More complex rotation patterns for each collectible
                item.object.rotation.x += item.rotation.x;
                item.object.rotation.y += item.rotation.y;
                item.object.rotation.z += item.rotation.z;
                
                // Float up and down with sine wave
                item.object.position.y = item.position.y + Math.sin(Date.now() * 0.002) * 0.5;
                
                // Pulsate scale
                const scale = 1 + Math.sin(Date.now() * 0.003) * 0.1;
                item.object.scale.set(scale, scale, scale);
                
                // Make inner objects rotate in opposite direction (first child)
                if (item.object.children && item.object.children.length > 0) {
                    item.object.children[0].rotation.y -= 0.03;
                }
            }
        });
        
        // Broadcast position at a reasonable rate (10 times per second)
        if (peer && connections.length > 0 && Date.now() % 100 < 20) {
            broadcastPosition();
        }
        
        // Periodically sync full player state
        syncMultiplayerState();
        
        // Smooth update for each other player
        Object.values(otherPlayers).forEach(p => {
            if (p.mesh) {
                p.mesh.position.lerp(p.position, 0.2);
                p.mesh.rotation.y = p.angle;
            }
        });
        
        // Remove stale players (disconnected but not caught by close event)
        const now = Date.now();
        Object.keys(otherPlayers).forEach(id => {
            // Increase timeout to 20 seconds for better persistence
            if (now - otherPlayers[id].lastUpdate > 20000) {
                removeOtherPlayerCar(id);
            }
        });
        
        // Update minimap if it exists
        if (document.getElementById('minimap')) {
            updateMinimapMarkers();
        }
        
        renderer.render(scene, camera);
    }

    // Update FPS counter
    function updateFPS() {
        fpsCounter.frames++;
        const now = performance.now();
        const elapsed = now - fpsCounter.lastTime;
        
        if (elapsed >= 1000) { // Update once per second
            const fps = Math.round((fpsCounter.frames * 1000) / elapsed);
            document.getElementById('fpsCounter').textContent = 'FPS: ' + fps;
            document.getElementById('fpsCounter').style.display = gameSettings.showFps ? 'block' : 'none';
            
            // Reset counters
            fpsCounter.frames = 0;
            fpsCounter.lastTime = now;
            
            // Auto-adjust quality if FPS is too low
            if (gameSettings.quality !== 'low' && fps < 30) {
                const currentQuality = gameSettings.quality;
                if (currentQuality === 'high') {
                    gameSettings.quality = 'medium';
                    console.log('Auto-reducing quality to medium due to low FPS');
                } else if (currentQuality === 'medium') {
                    gameSettings.quality = 'low';
                    console.log('Auto-reducing quality to low due to low FPS');
                }
            }
        }
    }

    function clearScene() {
        if (!scene) return;
        for (let i = scene.children.length - 1; i >= 0; i--) {
            const obj = scene.children[i];
            // Don't remove other players' cars
            if (obj.isMesh && !Object.values(otherPlayers).some(p => p.mesh === obj)) {
                scene.remove(obj);
                // Only dispose geometries and materials that aren't shared
                if (obj.geometry && !Object.values(sharedGeometries).includes(obj.geometry)) {
                    obj.geometry.dispose();
                }
                if (obj.material && !Object.values(sharedMaterials).includes(obj.material)) {
                    if (Array.isArray(obj.material)) {
                        obj.material.forEach(m => m.dispose());
                    } else {
                        obj.material.dispose();
                    }
                }
            }
        }
    }

    // --- Multiplayer Logic ---
    let peer = null;
    let connections = [];
    let isHost = false;
    let playerColor = '#' + Math.floor(Math.random()*16777215).toString(16);
    let otherPlayers = {}; // {peerId: {mesh, position, angle, lastUpdate}}
    let playerId = null;
    let playerIndices = {};      // maps peerId → numeric slot
    let nextPlayerIndex = 1;     // start with host = 1

    function joinOrCreateRoom(blockHash) {
        // Get player name from input
        playerName = document.getElementById('playerName').value.trim();
        if (!playerName) playerName = "Player" + Math.floor(Math.random() * 1000);

        // If already connected to a peer with the same block, do nothing
        if (peer && cachedBlockHash === blockHash) {
            console.log("Already connected with this block");
            return;
        }
        
        // If connected to a different block, disconnect first
        if (peer) {
            console.log("Disconnecting from previous room");
            connections.forEach(conn => {
                if (conn.open) conn.close();
            });
            connections = [];
            peer.disconnect();
            peer.destroy();
            peer = null;
            isHost = false;
        }

        // First load the block data regardless of hosting/joining
        showLoading(true, 10, "Loading block data...");
        loadBlockData(blockHash).then(() => {
            // Now attempt to connect to the room
            showLoading(true, 50, "Connecting to room...");
            
            // Use more reliable options for peer connection
            const peerOptions = {
                debug: 1, // Lower debug level for less console spam
                config: {
                    'iceServers': [
                        { urls: 'stun:stun.l.google.com:19302' },
                        { urls: 'stun:stun1.l.google.com:19302' },
                        { 
                            urls: 'turn:numb.viagenie.ca',
                            username: 'webrtc@live.com',
                            credential: 'muazkh'
                        }
                    ]
                }
            };
            
            // Use a shorter room ID to avoid issues
            // Create a more consistent ID from the block hash
            const roomId = 'bcar_' + blockHash.substring(0, 12);
            
            const hostPeer = new Peer(roomId, peerOptions);

            hostPeer.on('open', id => {
                // Host: first to enter the room
                isHost = true;
                peer = hostPeer;
                playerId = id;
                playerIndices[id] = 1;
                showLoading(false, 100, "Ready as host!");
                playSound('connected');
                
                peer.on('connection', handleConnection);

                // Show race controls for host
                document.getElementById('raceControls').style.display = 'block';
                
                // Update room status in known rooms
                knownRooms[blockHash] = {
                    id: blockHash,
                    roomId: roomId,
                    playerCount: 1,
                    lastSeen: Date.now()
                };
                updateRoomsList();
            });

            hostPeer.on('error', err => {
                console.log("Host peer error, joining as client:", err);
                // If room exists, join as client
                
                // Use a shorter room ID to avoid issues
                const roomId = 'bcar_' + blockHash.substring(0, 12);
                
                peer = new Peer(null, peerOptions);
                peer.on('open', id => {
                    playerId = id;
                    playerIndices[playerId] = nextPlayerIndex++;
                    showLoading(true, 75, "Joining existing room...");
                    
                    try {
                        const conn = peer.connect(roomId, {
                            reliable: true,
                            serialization: 'json',
                            metadata: {
                                playerName: playerName,
                                playerColor: playerColor
                            }
                        });
                        
                        // Add timeout check in case connection never opens
                        const connectionTimeout = setTimeout(() => {
                            console.error("Connection timed out");
                            showLoading(true, 100, "Connection timed out, could not join room");
                            setTimeout(() => showLoading(false), 2000);
                            if (conn && !conn.open) {
                                conn.close();
                            }
                        }, 10000); // 10 second timeout
                        
                        conn.on('open', () => {
                            clearTimeout(connectionTimeout);
                            handleConnection(conn);
                            showLoading(false, 100, "Connected as client!");
                        });
                        
                        conn.on('error', (connErr) => {
                            clearTimeout(connectionTimeout);
                            console.error("Connection error:", connErr);
                            showLoading(true, 100, "Connection error: " + connErr.message);
                            setTimeout(() => showLoading(false), 2000);
                        });
                        
                        // Update room status in known rooms
                        if (knownRooms[blockHash]) {
                            knownRooms[blockHash].playerCount++;
                            knownRooms[blockHash].lastSeen = Date.now();
                        } else {
                            knownRooms[blockHash] = {
                                id: blockHash,
                                roomId: roomId,
                                playerCount: 2, // Host + this client
                                lastSeen: Date.now()
                            };
                        }
                        updateRoomsList();
                    } catch (connErr) {
                        console.error("Error creating connection:", connErr);
                        showLoading(true, 100, "Error creating connection");
                        setTimeout(() => showLoading(false), 2000);
                    }
                });
                
                peer.on('error', clientErr => {
                    console.error("Client peer error:", clientErr);
                    showLoading(true, 100, "Connection error: " + clientErr.message);
                    setTimeout(() => showLoading(false), 2000);
                });
            });
        });

        // Add race control event listeners
        const startRaceButton = document.getElementById('startRaceButton');
        startRaceButton.addEventListener('click', startRace);
        
        // Remove existing listener to prevent duplicates
        startRaceButton.removeEventListener('click', startRace);
        startRaceButton.addEventListener('click', startRace);
    }

    // Add track details (barriers, decorations) at intervals
    function addTrackDetail(position, rotation) {
        // Add some random track details like barriers or decorations
        const detailTypes = ['barrier', 'pillar', 'light'];
        const detailType = detailTypes[Math.floor(Math.random() * detailTypes.length)];
        
        switch(detailType) {
            case 'barrier':
                // Create a simple barrier
                const barrierGeo = new THREE.BoxGeometry(1, 1, 3);
                const barrierMat = new THREE.MeshPhongMaterial({
                    color: 0xdddddd,
                    shininess: 50
                });
                const barrier = new THREE.Mesh(barrierGeo, barrierMat);
                
                // Position at side of track
                const sideOffset = trackWidth/2 + 1;
                barrier.position.set(
                    position.x + Math.sin(rotation + Math.PI/2) * sideOffset,
                    position.y + 0.5,
                    position.z + Math.cos(rotation + Math.PI/2) * sideOffset
                );
                barrier.rotation.y = rotation;
                
                // Add stripe
                const stripeGeo = new THREE.BoxGeometry(1.1, 0.2, 3.1);
                const stripeMat = new THREE.MeshPhongMaterial({
                    color: 0xff0000,
                    shininess: 80
                });
                const stripe = new THREE.Mesh(stripeGeo, stripeMat);
                stripe.position.y = 0.2;
                barrier.add(stripe);
                
                scene.add(barrier);
                break;
                
            case 'pillar':
                // Create a column/pillar
                const pillarGeo = new THREE.CylinderGeometry(0.5, 0.7, 5, 8);
                const pillarMat = new THREE.MeshPhongMaterial({
                    color: 0x888888,
                    shininess: 60
                });
                const pillar = new THREE.Mesh(pillarGeo, pillarMat);
                
                // Position at side of track
                const pillarOffset = trackWidth/2 + 3;
                pillar.position.set(
                    position.x + Math.sin(rotation + Math.PI/2) * pillarOffset,
                    position.y + 2.5,
                    position.z + Math.cos(rotation + Math.PI/2) * pillarOffset
                );
                
                // Add a cap
                const capGeo = new THREE.CylinderGeometry(0.7, 0.7, 0.3, 8);
                const capMat = new THREE.MeshPhongMaterial({
                    color: 0x666666,
                    shininess: 70
                });
                const cap = new THREE.Mesh(capGeo, capMat);
                cap.position.y = 2.5;
                pillar.add(cap);
                
                scene.add(pillar);
                break;
                
            case 'light':
                // Create a light post
                const postGeo = new THREE.CylinderGeometry(0.2, 0.2, 6, 6);
                const postMat = new THREE.MeshPhongMaterial({
                    color: 0x333333,
                    shininess: 40
                });
                const post = new THREE.Mesh(postGeo, postMat);
                
                // Position at side of track
                const postOffset = trackWidth/2 + 2;
                post.position.set(
                    position.x + Math.sin(rotation + Math.PI/2) * postOffset,
                    position.y + 3,
                    position.z + Math.cos(rotation + Math.PI/2) * postOffset
                );
                
                // Add a light
                const lightGeo = new THREE.SphereGeometry(0.5, 8, 8);
                const lightMat = new THREE.MeshPhongMaterial({ 
                    color: 0xffff00,
                    emissive: 0xffff00,
                    emissiveIntensity: 0.5,
                    shininess: 90
                });
                const lightBulb = new THREE.Mesh(lightGeo, lightMat);
                lightBulb.position.y = 3;
                post.add(lightBulb);
                
                scene.add(post);
                break;
        }
    }

    function handleConnection(conn) {
        if (!playerIndices[conn.peer]) {
            playerIndices[conn.peer] = nextPlayerIndex++;
        }
        connections.push(conn);
        
        // Set connection options for reliability
        conn.serialization = 'json';
        conn.reliable = true;

        conn.on('open', () => {
            // Host sends only essential data to new joiner
            if (isHost && blockMetadata) {
                // Instead of sending all transactions, send only metadata and block hash
                conn.send({
                    type: 'init',
                    blockData: {
                        // Don't send full transactions array - too large
                        metadata: blockMetadata,
                        blockHash: cachedBlockHash
                    }
                });
            }
            // Everyone shares color & ID
            conn.send({
                type: 'playerInfo',
                playerColor: playerColor,
                playerId: playerId,
                playerIndex: playerIndices[playerId],
                playerName: playerName
            });
            showLoading(false, 100, "Connected!");
            updatePlayersList();
            playSound('connected');
        });

        conn.on('data', data => {
            switch(data.type) {
                case 'init':
                    // Only load block if not already loaded
                    if (data.blockData && (!cachedBlockHash || cachedBlockHash !== data.blockData.blockHash)) {
                        blockMetadata = data.blockData.metadata;
                        cachedBlockHash = data.blockData.blockHash;
                        
                        // Client can't receive full transaction data due to size limits
                        // Instead, it should load the block data itself
                        if (cachedBlockHash && !storedTransactions.length) {
                            loadBlockData(cachedBlockHash).then(() => {
                                updateBlockInfo(blockMetadata);
                                updatePlayerCount();
                            });
                        }
                    }
                    break;
                case 'playerInfo':
                    createOtherPlayerCar(data.playerId, data.playerColor, data.playerName);
                    playerIndices[data.playerId] = data.playerIndex || nextPlayerIndex++;
                    updatePlayersList();
                    break;
                case 'position':
                    updateOtherPlayerPosition(conn.peer, data);
                    break;
                case 'resetToStart':
                    if (respawnPoint) {
                        carPosition.copy(respawnPoint.pos);
                        carAngle = respawnPoint.angle;
                        carVelocity.set(0, 0, 0);
                        carSpeed = 0;
                        raceFinished = false;
                        finishLinePassed = false;
                    }
                    break;
                case 'startRaceCountdown':
                    startRaceCountdown();
                    break;
                case 'playerFinished':
                    // Record other player's finish time
                    raceTimes[data.playerId] = data.time;
                    // Show notification
                    const pIndex = playerIndices[data.playerId] || '?';
                    const minutes = Math.floor(data.time / 60000);
                    const seconds = Math.floor((data.time % 60000) / 1000);
                    const ms = data.time % 1000;
                    const timeStr = `${minutes}:${seconds.toString().padStart(2, '0')}.${ms.toString().padStart(3, '0')}`;
                    const notification = document.createElement('div');
                    notification.textContent = `Player ${pIndex} finished in ${timeStr}!`;
                    notification.style.position = 'absolute';
                    notification.style.bottom = '100px';
                    notification.style.left = '50%';
                    notification.style.transform = 'translateX(-50%)';
                    notification.style.color = '#ffa94d';
                    notification.style.background = 'rgba(0,0,0,0.7)';
                    notification.style.padding = '8px 16px';
                    notification.style.borderRadius = '4px';
                    notification.style.zIndex = '15';
                    document.body.appendChild(notification);
                    setTimeout(() => document.body.removeChild(notification), 5000);
                    break;
                case 'forceResetToStart':
                    // Force reset the player position to start using exact coordinates
                    if (data.startPos) {
                        carPosition.set(data.startPos.x, data.startPos.y, data.startPos.z);
                        carAngle = data.startPos.angle;
                        carVelocity.set(0, 0, 0);
                        carSpeed = 0;
                        raceFinished = false;
                        finishLinePassed = false;
                        
                        // Update respawn point too
                        respawnPoint = {
                            pos: new THREE.Vector3(data.startPos.x, data.startPos.y, data.startPos.z),
                            angle: data.startPos.angle
                        };
                    } else if (respawnPoint) {
                        // Fallback to local respawnPoint if no position data provided
                        carPosition.copy(respawnPoint.pos);
                        carAngle = respawnPoint.angle;
                        carVelocity.set(0, 0, 0);
                        carSpeed = 0;
                        raceFinished = false;
                        finishLinePassed = false;
                    }
                    break;
                case 'playerHit':
                    // Visual feedback when hit by another player
                    handleBeingHit(data.fromPlayerId);
                    break;
                case 'nameUpdate':
                    // Update other player's name
                    if (otherPlayers[data.playerId]) {
                        updateOtherPlayerName(data.playerId, data.newName);
                    }
                    break;
                case 'playerState':
                    // Handle full state update
                    if (otherPlayers[data.id]) {
                        const player = otherPlayers[data.id];
                        // Update all player properties from the state sync
                        if (data.position) {
                            player.position.set(data.position.x, data.position.y, data.position.z);
                        }
                        if (data.angle !== undefined) {
                            player.angle = data.angle;
                        }
                        if (data.playerName && player.name !== data.playerName) {
                            updateOtherPlayerName(data.id, data.playerName);
                        }
                        player.lastUpdate = Date.now();
                    }
                    break;
            }
        });

        conn.on('close', () => {
            connections = connections.filter(c => c !== conn);
            removeOtherPlayerCar(conn.peer);
            updatePlayersList();
            
            // Update room status
            if (knownRooms[cachedBlockHash]) {
                knownRooms[cachedBlockHash].playerCount = Math.max(1, knownRooms[cachedBlockHash].playerCount - 1);
                updateRoomsList();
            }
        });
        
        // Handle errors
        conn.on('error', err => {
            console.error("Connection error:", err);
            connections = connections.filter(c => c !== conn);
            removeOtherPlayerCar(conn.peer);
            updatePlayersList();
        });
    }
    
    // Wrap hit handler to enforce 5s invulnerability
    function handleBeingHit(fromPlayerId) {
        if (invulnerable) return;
        invulnerable = true;
        setTimeout(() => { invulnerable = false; }, 5000);

        // Visual effect when hit
        const hitFeedback = document.createElement('div');
        hitFeedback.textContent = 'HIT!';
        hitFeedback.style.position = 'absolute';
        hitFeedback.style.top = '40%';
        hitFeedback.style.left = '50%';
        hitFeedback.style.transform = 'translate(-50%, -50%)';
        hitFeedback.style.color = '#ff3333';
        hitFeedback.style.fontSize = '3em';
        hitFeedback.style.fontWeight = 'bold';
        hitFeedback.style.zIndex = '20';
        hitFeedback.style.textShadow = '0 0 10px #ff0000';
        document.body.appendChild(hitFeedback);
        
        // Also add screen flash
        const flash = document.createElement('div');
        flash.style.position = 'fixed';
        flash.style.top = '0';
        flash.style.left = '0';
        flash.style.width = '100%';
        flash.style.height = '100%';
        flash.style.background = 'rgba(255,0,0,0.3)';
        flash.style.zIndex = '10';
        flash.style.pointerEvents = 'none';
        document.body.appendChild(flash);
        
        // Play hit sound
        playSound('hit');
        
        // Remove feedback
        setTimeout(() => {
            document.body.removeChild(hitFeedback);
            document.body.removeChild(flash);
        }, 500);
        
        // Actual gameplay effect - temporary slow down
        carSpeed = Math.max(carSpeed - 1.0, 0);
    }

    function updateCarColor(colorHex) {
        if (!car) return;
        // Convert hex string to number for Three.js
        const colorNum = parseInt(colorHex.replace('#', '0x'), 16);
        car.material.color.set(colorNum);
    }

    function updatePlayersList() {
        const list = document.getElementById('playersList');
        if (!list) return; // Add safety check
        
        list.innerHTML = '<p><strong>Players:</strong></p>';
        
        // Add yourself
        const selfItem = document.createElement('div');
        selfItem.textContent = playerName + (isHost ? ' (Host)' : '');
        selfItem.style.color = playerColor;
        list.appendChild(selfItem);
        
        // Add other players
        Object.keys(otherPlayers).forEach(id => {
            const playerItem = document.createElement('div');
            playerItem.textContent = otherPlayers[id].name || id.substring(0, 8) + '...';
            playerItem.style.color = otherPlayers[id].color;
            list.appendChild(playerItem);
        });
        
        // Update player count in race controls
        document.getElementById('playerCount').textContent = Object.keys(otherPlayers).length + 1;
    }

    // --- Minimap Implementation ---
    let minimapTrack = [];
    let minimapBounds = {
        minX: 0, maxX: 0,
        minZ: 0, maxZ: 0,
        width: 0, height: 0
    };
    
    function initMinimap() {
        // Create minimap container if it doesn't exist
        const minimap = document.getElementById('minimap');
        minimap.innerHTML = '';
        
        if (trackSegments && trackSegments.length > 0) {
            // Calculate track bounds
            calculateTrackBounds();
            
            // Create track visualization
            drawTrackOnMinimap();
        }
        
        // Create player marker
        const playerMarker = document.createElement('div');
        playerMarker.className = 'playerMarker';
        playerMarker.id = 'playerMarker';
        playerMarker.style.backgroundColor = playerColor;
        minimap.appendChild(playerMarker);
        
        // Update markers immediately
        updateMinimapMarkers();
    }
    
    function calculateTrackBounds() {
        minimapBounds.minX = Infinity;
        minimapBounds.maxX = -Infinity;
        minimapBounds.minZ = Infinity;
        minimapBounds.maxZ = -Infinity;
        
        // Find min/max coordinates of track
        trackSegments.forEach(segment => {
            minimapBounds.minX = Math.min(minimapBounds.minX, segment.p1.x, segment.p2.x);
            minimapBounds.maxX = Math.max(minimapBounds.maxX, segment.p1.x, segment.p2.x);
            minimapBounds.minZ = Math.min(minimapBounds.minZ, segment.p1.z, segment.p2.z);
            minimapBounds.maxZ = Math.max(minimapBounds.maxZ, segment.p1.z, segment.p2.z);
        });
        
        // Add some padding
        const padding = 20;
        minimapBounds.minX -= padding;
        minimapBounds.maxX += padding;
        minimapBounds.minZ -= padding;
        minimapBounds.maxZ += padding;
        
        minimapBounds.width = minimapBounds.maxX - minimapBounds.minX;
        minimapBounds.height = minimapBounds.maxZ - minimapBounds.minZ;
    }
    
    function drawTrackOnMinimap() {
        const minimap = document.getElementById('minimap');
        const minimapWidth = minimap.clientWidth;
        const minimapHeight = minimap.clientHeight;
        
        // Create SVG for track
        const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
        svg.setAttribute('width', '100%');
        svg.setAttribute('height', '100%');
        svg.style.position = 'absolute';
        
        // Draw each track segment
        trackSegments.forEach(segment => {
            // Convert 3D positions to minimap coordinates
            const x1 = mapValue(segment.p1.x, minimapBounds.minX, minimapBounds.maxX, 0, minimapWidth);
            const y1 = mapValue(segment.p1.z, minimapBounds.minZ, minimapBounds.maxZ, 0, minimapHeight);
            const x2 = mapValue(segment.p2.x, minimapBounds.minX, minimapBounds.maxX, 0, minimapWidth);
            const y2 = mapValue(segment.p2.z, minimapBounds.minZ, minimapBounds.maxZ, 0, minimapHeight);
            
            // Create line
            const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
            line.setAttribute('x1', x1);
            line.setAttribute('y1', y1);
            line.setAttribute('x2', x2);
            line.setAttribute('y2', y2);
            line.setAttribute('stroke', '#888');
            line.setAttribute('stroke-width', '2');
            svg.appendChild(line);
        });
        
        // Add start and finish markers
        if (startLineObj) {
            const startPos = startLineObj.position;
            const startX = mapValue(startPos.x, minimapBounds.minX, minimapBounds.maxX, 0, minimapWidth);
            const startY = mapValue(startPos.z, minimapBounds.minZ, minimapBounds.maxZ, 0, minimapHeight);
            
            const startMarker = document.createElementNS("http://www.w3.org/2000/svg", "circle");
            startMarker.setAttribute('cx', startX);
            startMarker.setAttribute('cy', startY);
            startMarker.setAttribute('r', '4');
            startMarker.setAttribute('fill', '#00ff00');
            svg.appendChild(startMarker);
        }
        
        if (finishLineObj) {
            const finishPos = finishLineObj.position;
            const finishX = mapValue(finishPos.x, minimapBounds.minX, minimapBounds.maxX, 0, minimapWidth);
            const finishY = mapValue(finishPos.z, minimapBounds.minZ, minimapBounds.maxZ, 0, minimapHeight);
            
            const finishMarker = document.createElementNS("http://www.w3.org/2000/svg", "circle");
            finishMarker.setAttribute('cx', finishX);
            finishMarker.setAttribute('cy', finishY);
            finishMarker.setAttribute('r', '4');
            finishMarker.setAttribute('fill', '#ff0000');
            svg.appendChild(finishMarker);
        }
        
        minimap.appendChild(svg);
    }

    function updateMinimapMarkers() {
        if (!minimapBounds || minimapBounds.width === 0) return;
        
        const minimap = document.getElementById('minimap');
        const minimapWidth = minimap.clientWidth;
        const minimapHeight = minimap.clientHeight;
        
        // Update player marker
        const playerMarker = document.getElementById('playerMarker');
        if (playerMarker && carPosition) {
            const playerX = mapValue(carPosition.x, minimapBounds.minX, minimapBounds.maxX, 0, minimapWidth);
            const playerZ = mapValue(carPosition.z, minimapBounds.minZ, minimapBounds.maxZ, 0, minimapHeight);
            playerMarker.style.left = playerX + 'px';
            playerMarker.style.top = playerZ + 'px';
            
            // Add direction indicator (small arrow)
            playerMarker.style.transform = `translate(-50%, -50%) rotate(${-carAngle}rad)`;
        }
        
        // Update other players' markers
        Object.keys(otherPlayers).forEach(id => {
            const player = otherPlayers[id];
            let marker = document.getElementById('marker-' + id);
            
            if (!marker) {
                marker = document.createElement('div');
                marker.className = 'otherPlayerMarker';
                marker.id = 'marker-' + id;
                marker.style.backgroundColor = player.color;
                minimap.appendChild(marker);
            }
            
            const x = mapValue(player.position.x, minimapBounds.minX, minimapBounds.maxX, 0, minimapWidth);
            const z = mapValue(player.position.z, minimapBounds.minZ, minimapBounds.maxZ, 0, minimapHeight);
            
            marker.style.left = x + 'px';
            marker.style.top = z + 'px';
        });
        
        // Remove markers for disconnected players
        document.querySelectorAll('.otherPlayerMarker').forEach(marker => {
            const id = marker.id.replace('marker-', '');
            if (!otherPlayers[id]) {
                marker.remove();
            }
        });
    }
    
    function createOtherPlayerCar(peerId, colorHex, playerName) {
        if (otherPlayers[peerId]) removeOtherPlayerCar(peerId);
        
        let geometry = sharedGeometries.car.clone();
        // Convert hex string to number for Three.js
        const colorNum = parseInt(colorHex.replace('#', '0x'), 16);
        let material = new THREE.MeshPhongMaterial({ 
            color: colorNum,
            emissive: new THREE.Color(colorNum).multiplyScalar(0.3) // Keep emissive for MeshPhongMaterial
        });
        let playerCar = new THREE.Mesh(geometry, material);
        scene.add(playerCar);
        
        // Add visible identifier with larger text and name
        const idx = playerIndices[peerId] || ('?' );
        const displayName = playerName || ('P' + idx);
        const playerLabel = createPlayerLabel('P' + idx, displayName);
        playerLabel.position.set(0, 4, 0); // Position higher above car
        playerLabel.scale.set(4, 2, 1);    // Make it larger
        playerCar.add(playerLabel);
        
        // Add highlighting effect with corrected material (no emissive)
        const highlightGeo = new THREE.BoxGeometry(3.5, 2.5, 5.5);
        const highlightMat = new THREE.MeshBasicMaterial({
            color: colorNum,
            transparent: true,
            opacity: 0.2,
            wireframe: false
        });
        const highlight = new THREE.Mesh(highlightGeo, highlightMat);
        playerCar.add(highlight);
        
        // Add car details for higher quality settings
        if (gameSettings.quality !== 'low') {
            addCarWheels(playerCar);
        }
        
        otherPlayers[peerId] = {
            mesh: playerCar,
            position: new THREE.Vector3(0, 5, 10),
            angle: 0,
            lastUpdate: Date.now(),
            color: colorHex,
            highlight: highlight,
            name: playerName || 'Unknown'
        };
        
        // Update player list display
        updatePlayersList();
        // Update minimap markers
        updateMinimapMarkers();
        
        // Play sound for new player
        playSound('playerJoined');
        
        console.log("Created player car for:", peerId);
    }
    
    // Create a floating label above player cars
    function createPlayerLabel(text, playerName) {
        const canvas = document.createElement('canvas');
        const context = canvas.getContext('2d');
        canvas.width = 128;
        canvas.height = 64;
        
        // Draw background - using semi-transparent for better visibility
        context.fillStyle = 'rgba(0,0,0,0.7)';
        context.fillRect(0, 0, canvas.width, canvas.height);
        
        // Draw border
        context.strokeStyle = '#ffffff';
        context.lineWidth = 2;
        context.strokeRect(2, 2, canvas.width-4, canvas.height-4);
        
        // Use provided name or default to numeric ID
        const displayText = playerName ? playerName : text;
        
        // Draw text - larger and bold
        context.font = 'bold 28px Arial';
        context.fillStyle = '#ffffff';
        context.textAlign = 'center';
        context.textBaseline = 'middle';
        context.fillText(displayText, canvas.width/2, canvas.height/2);
        
        // Create sprite
        const texture = new THREE.CanvasTexture(canvas);
        const material = new THREE.SpriteMaterial({ 
            map: texture,
            transparent: true,
            depthTest: false // Always render on top
        });
        const sprite = new THREE.Sprite(material);
        sprite.position.set(0, 3, 0); // Position above car
        sprite.scale.set(3, 1.5, 1);
        
        return sprite;
    }
    
    function updateOtherPlayerPosition(peerId, data) {
        if (!otherPlayers[peerId]) createOtherPlayerCar(peerId, data.color, data.playerName);
        const p = otherPlayers[peerId];
        p.position.set(data.x, data.y, data.z);
        p.angle = data.angle;
        p.lastUpdate = Date.now();
        p.name = data.playerName || p.name;
    }
    
    function updateOtherPlayerName(peerId, newName) {
        if (!otherPlayers[peerId]) return;
        
        otherPlayers[peerId].name = newName;
        
        // Update the label
        if (otherPlayers[peerId].mesh && otherPlayers[peerId].mesh.children.length > 0) {
            // Find the label sprite (first child)
            const label = otherPlayers[peerId].mesh.children[0];
            if (label && label.isSprite) {
                // Create new label
                const newLabel = createPlayerLabel('P' + playerIndices[peerId], newName);
                newLabel.position.copy(label.position);
                newLabel.scale.copy(label.scale);
                
                // Replace old label
                otherPlayers[peerId].mesh.remove(label);
                otherPlayers[peerId].mesh.add(newLabel);
            }
        }
        
        // Update players list
        updatePlayersList();
    }
    
    function broadcastPosition() {
        if (!peer || !carPosition) return;
        
        const posData = {
            type: 'position',
            x: carPosition.x,
            y: carPosition.y,
            z: carPosition.z,
            angle: carAngle,
            color: playerColor,
            playerName: playerName
        };
        
        connections.forEach(conn => {
            if (conn.open) {
                conn.send(posData);
            }
        });
    }
    
    // Periodically sync full state for reliability
    function syncMultiplayerState() {
        // Only sync every 5 seconds to reduce traffic
        if (!peer || !connections.length || Date.now() % 5000 > 100) return;
        
        const fullState = {
            type: 'playerState',
            id: playerId,
            position: {
                x: carPosition.x,
                y: carPosition.y,
                z: carPosition.z
            },
            angle: carAngle,
            playerName: playerName
        };
        
        connections.forEach(conn => {
            if (conn.open) {
                conn.send(fullState);
            }
        });
    }
    
    function removeOtherPlayerCar(peerId) {
        if (otherPlayers[peerId]) {
            scene.remove(otherPlayers[peerId].mesh);
            delete otherPlayers[peerId];
            updatePlayersList();
            
            // Remove from minimap
            const marker = document.getElementById('marker-' + peerId);
            if (marker) marker.remove();
            
            // Play sound
            playSound('playerLeft');
        }
    }
    
    function createStartAndFinishLines(track) {
        // Remove previous lines if they exist
        if (startLineObj && startLineObj.parent) startLineObj.parent.remove(startLineObj);
        if (finishLineObj && finishLineObj.parent) finishLineObj.parent.remove(finishLineObj);
        
        if (!track || !track.length) return;
        
        // Create start line at first track segment
        const startSeg = track[0];
        const startLineGeo = new THREE.PlaneGeometry(startSeg.width * 1.2, 3);
        const startLineMat = new THREE.MeshBasicMaterial({
            color: 0x00ff00,
            side: THREE.DoubleSide,
            transparent: true,
            opacity: 0.8
        });
        startLineObj = new THREE.Mesh(startLineGeo, startLineMat);
        
        // Position at the beginning of track
        startLineObj.position.copy(startSeg.p1);
        startLineObj.position.y += 0.2; // Slightly above track
        
        // Determine rotation
        const startDir = new THREE.Vector3().subVectors(startSeg.p2, startSeg.p1).normalize();
        startLineObj.rotation.y = Math.atan2(startDir.x, startDir.z) + Math.PI/2;
        startLineObj.rotation.x = Math.PI/2;
        
        scene.add(startLineObj);
        
        // Create finish line near the end of the track
        const finishSegIdx = Math.max(0, track.length - 3);
        const finishSeg = track[finishSegIdx];
        const finishLineGeo = new THREE.PlaneGeometry(finishSeg.width * 1.2, 3);
        const finishLineMat = new THREE.MeshBasicMaterial({
            color: 0xff0000,
            side: THREE.DoubleSide,
            transparent: true,
            opacity: 0.8
        });
        finishLineObj = new THREE.Mesh(finishLineGeo, finishLineMat);
        
        // Position at the end of track
        finishLineObj.position.copy(finishSeg.p2);
        finishLineObj.position.y += 0.2; // Slightly above track
        
        // Determine rotation
        const finishDir = new THREE.Vector3().subVectors(finishSeg.p2, finishSeg.p1).normalize();
        finishLineObj.rotation.y = Math.atan2(finishDir.x, finishDir.z) + Math.PI/2;
        finishLineObj.rotation.x = Math.PI/2;
        
        scene.add(finishLineObj);
        
        // Add checkered pattern for higher quality
        if (gameSettings.quality !== 'low') {
            // Add checkered flag pattern to finish line
            const checkerSize = 0.5;
            const rows = 6;
            const cols = Math.ceil(finishSeg.width * 1.2 / checkerSize);
            
            for (let i = 0; i < rows; i++) {
                for (let j = 0; j < cols; j++) {
                    if ((i + j) % 2 === 0) continue; // Skip every other square
                    
                    const checkerGeo = new THREE.PlaneGeometry(checkerSize, checkerSize);
                    const checkerMat = new THREE.MeshBasicMaterial({ 
                        color: 0x000000,
                        side: THREE.DoubleSide
                    });
                    const checker = new THREE.Mesh(checkerGeo, checkerMat);
                    
                    // Position on the finish line
                    checker.position.x = (j - cols/2 + 0.5) * checkerSize;
                    checker.position.y = 0.01; // Slightly above the line
                    checker.position.z = (i - rows/2 + 0.5) * checkerSize;
                    
                    finishLineObj.add(checker);
                }
            }
        }
    }
    
    function startRace() {
        if (!isHost || !connections.length) return;
        
        // Reset all players to start position and broadcast
        resetAllPlayersToStart();
        
        // Start countdown
        broadcastStartRace();
    }
    
    function resetAllPlayersToStart() {
        // Reset our own position to the very beginning of the track
        if (trackSegments && trackSegments.length > 0) {
            // Always use the very first segment
            const startSeg = trackSegments[0];
            const startPos = startSeg.p1.clone();
            startPos.y += 2; // Elevate slightly to avoid collision issues
            
            // Calculate angle based on direction from p1 to p2
            const startDir = new THREE.Vector3().subVectors(startSeg.p2, startSeg.p1).normalize();
            const startAngle = Math.atan2(startDir.x, startDir.z);
            
            // Force position reset for local player
            carPosition.copy(startPos);
            carAngle = startAngle;
            carVelocity.set(0, 0, 0);
            carSpeed = 0;
            raceFinished = false;
            finishLinePassed = false;
            
            // Update respawn point to match
            respawnPoint = {
                pos: startPos,
                angle: startAngle
            };
        }
        
        // Tell others to reset with an EXPLICIT command
        connections.forEach(conn => {
            if (conn.open) {
                conn.send({
                    type: 'forceResetToStart',
                    startPos: respawnPoint ? {
                        x: respawnPoint.pos.x,
                        y: respawnPoint.pos.y,
                        z: respawnPoint.pos.z,
                        angle: respawnPoint.angle
                    } : null
                });
            }
        });
    }
    
    function broadcastStartRace() {
        connections.forEach(conn => {
            if (conn.open) {
                conn.send({
                    type: 'startRaceCountdown'
                });
            }
        });
        
        // Start our own countdown too
        startRaceCountdown();
    }
    
    function startRaceCountdown() {
        const countdown = document.getElementById('countdown');
        countdown.style.display = 'block';
        
        // Lock controls during countdown
        controlsLocked = true;
        
        // Play countdown sounds
        playSound('countdown');
        
        // 3...2...1...GO sequence
        countdown.textContent = '3';
        setTimeout(() => {
            countdown.textContent = '2';
            playSound('countdown');
            setTimeout(() => {
                countdown.textContent = '1';
                playSound('countdown');
                setTimeout(() => {
                    countdown.textContent = 'GO!';
                    raceActive = true;
                    raceStartTime = Date.now();
                    controlsLocked = false; // Enable controls on GO
                    
                    // Play start sound
                    playSound('raceStart');
                    
                    // Start spawning enemies
                    spawnEnemies();
                    
                    // Hide countdown after a moment
                    setTimeout(() => {
                        countdown.style.display = 'none';
                    }, 1000);
                }, 1000);
            }, 1000);
        }, 1000);
    }
    
    function checkFinishLine() {
        if (!finishLineObj || finishLinePassed) return;
        
        const distToFinish = carPosition.distanceTo(finishLineObj.position);
        if (distToFinish < 5) {
            finishLinePassed = true;
            const finishTime = Date.now() - raceStartTime;
            
            // Display finish time
            const minutes = Math.floor(finishTime / 60000);
            const seconds = Math.floor((finishTime % 60000) / 1000);
            const ms = finishTime % 1000;
            const timeStr = `${minutes}:${seconds.toString().padStart(2, '0')}.${ms.toString().padStart(3, '0')}`;
            
            const feedback = document.createElement('div');
            feedback.textContent = `Finish! Time: ${timeStr}`;
            feedback.style.position = 'absolute';
            feedback.style.top = '30%';
            feedback.style.left = '50%';
            feedback.style.transform = 'translate(-50%, -50%)';
            feedback.style.color = '#ff0000';
            feedback.style.fontSize = '2em';
            feedback.style.fontWeight = 'bold';
            feedback.style.zIndex = '100';
            document.body.appendChild(feedback);
            
            // Play finish sound
            playSound('finish');
            
            // Add bonus points for finishing race
            score += 1000;
            updateGameUI();
            
            // Remove after a few seconds
            setTimeout(() => {
                document.body.removeChild(feedback);
            }, 5000);
            
            // Broadcast finish to other players
            if (peer && connections.length) {
                connections.forEach(conn => {
                    if (conn.open) {
                        conn.send({
                            type: 'playerFinished',
                            playerId: playerId,
                            time: finishTime
                        });
                    }
                });
            }
        }
    }
    
    // --- Available rooms list ---
    function updateRoomsList() {
        const roomsList = document.getElementById('roomsList');
        if (!roomsList) return;
        
        roomsList.innerHTML = '';
        
        // Remove rooms not seen in the last 5 minutes
        const now = Date.now();
        Object.keys(knownRooms).forEach(id => {
            if (now - knownRooms[id].lastSeen > 5 * 60 * 1000) {
                delete knownRooms[id];
            }
        });
        
        // Sort rooms by player count (descending)
        const sortedRooms = Object.values(knownRooms).sort((a, b) => 
            b.playerCount - a.playerCount
        );
        
        if (sortedRooms.length === 0) {
            const noRoomsMsg = document.createElement('div');
            noRoomsMsg.textContent = 'No active rooms found';
            noRoomsMsg.style.textAlign = 'center';
            noRoomsMsg.style.padding = '10px';
            noRoomsMsg.style.color = '#aaa';
            roomsList.appendChild(noRoomsMsg);
            return;
        }
        
        sortedRooms.forEach(room => {
            const roomItem = document.createElement('div');
            roomItem.className = 'room-item';
            
            const roomName = document.createElement('span');
            roomName.textContent = 'Block ' + (room.id.length > 8 ? room.id.substring(0, 8) + '...' : room.id);
            
            const playerCount = document.createElement('span');
            playerCount.className = 'room-players';
            playerCount.textContent = room.playerCount + ' 👤';
            
            roomItem.appendChild(roomName);
            roomItem.appendChild(playerCount);
            
            // Add current room indicator if applicable
            if (cachedBlockHash === room.id) {
                roomItem.style.border = '2px solid #ffa94d';
                roomItem.style.background = 'rgba(255,169,77,0.2)';
                
                const currentRoomBadge = document.createElement('span');
                currentRoomBadge.textContent = 'Current';
                currentRoomBadge.style.position = 'absolute';
                currentRoomBadge.style.top = '-8px';
                currentRoomBadge.style.right = '5px';
                currentRoomBadge.style.fontSize = '0.8em';
                currentRoomBadge.style.background = '#ffa94d';
                currentRoomBadge.style.color = '#181818';
                currentRoomBadge.style.padding = '2px 5px';
                currentRoomBadge.style.borderRadius = '3px';
                roomItem.style.position = 'relative';
                roomItem.appendChild(currentRoomBadge);
            }
            
            // Click to join room
            roomItem.addEventListener('click', () => {
                // Prevent clicking on current room
                if (cachedBlockHash !== room.id) {
                    document.getElementById('blockHash').value = room.id;
                    joinOrCreateRoom(room.id);
                }
            });
            
            roomsList.appendChild(roomItem);
        });
        
        // Add discover button to find new rooms
        const discoverButton = document.createElement('button');
        discoverButton.textContent = '🔍 Discover New Room';
        discoverButton.style.marginTop = '10px';
        discoverButton.style.width = '100%';
        discoverButton.style.padding = '8px';
        discoverButton.style.background = '#ffa94d';
        discoverButton.style.color = '#181818';
        discoverButton.style.border = 'none';
        discoverButton.style.borderRadius = '4px';
        discoverButton.style.cursor = 'pointer';
        discoverButton.style.fontWeight = 'bold';
        
        discoverButton.addEventListener('click', async () => {
            discoverButton.textContent = '🔍 Searching...';
            discoverButton.disabled = true;
            
            try {
                // Get a random block
                const randomBlock = await fetchLatestBlockInfo();
                if (randomBlock) {
                    document.getElementById('blockHash').value = randomBlock;
                    joinOrCreateRoom(randomBlock);
                }
            } catch (e) {
                console.error("Error discovering room:", e);
            } finally {
                discoverButton.textContent = '🔍 Discover New Room';
                discoverButton.disabled = false;
            }
        });
        
        roomsList.appendChild(discoverButton);
    }
    
    // --- Enemy System ---
    function spawnEnemies() {
        // Clear any existing enemy spawn interval
        if (enemySpawnInterval) {
            clearInterval(enemySpawnInterval);
        }
        
        // Start spawning enemies every few seconds
        enemySpawnInterval = setInterval(() => {
            if (raceActive && !gameOver) {
                spawnFallingHammer();
            }
        }, getDifficultyValue('enemySpawnRate')); // Spawn based on difficulty
    }
    
    // Get value based on difficulty setting
    function getDifficultyValue(property) {
        const difficultyValues = {
            enemySpawnRate: {
                'easy': 8000,     // 8 seconds between spawns
                'normal': 5000,   // 5 seconds between spawns
                'hard': 3000      // 3 seconds between spawns
            },
            enemySpeed: {
                'easy': 0.3,
                'normal': 0.4,
                'hard': 0.5
            },
            jumpCooldown: {
                'easy': 1000,
                'normal': 1500,
                'hard': 2000
            }
        };
        
        return difficultyValues[property][gameSettings.difficulty] || 
               difficultyValues[property]['normal']; // Default to normal
    }
    
    function spawnFallingHammer() {
        // Don't spawn if car position isn't defined yet
        if (!carPosition) return;
        
        // Create a position near the player but slightly ahead
        const offset = 30 + Math.random() * 40; // 30-70 units ahead
        const spread = 10 + Math.random() * 15; // 10-25 units to the side
        
        // Calculate position based on player direction
        const spawnPos = new THREE.Vector3(
            carPosition.x + (Math.cos(carAngle) * offset) + (Math.sin(carAngle) * spread * (Math.random() > 0.5 ? 1 : -1)),
            carPosition.y + 50, // High above
            carPosition.z + (Math.sin(carAngle) * offset) + (Math.cos(carAngle) * spread * (Math.random() > 0.5 ? 1 : -1))
        );
        
        // Create hammer geometry
        const hammerHead = new THREE.Group();
        
        // Head of hammer - use geometry instancing for better performance
        const headGeo = new THREE.BoxGeometry(4, 3, 4);
        const headMat = new THREE.MeshPhongMaterial({ color: 0x888888 });
        const head = new THREE.Mesh(headGeo, headMat);
        hammerHead.add(head);
        
        // Handle of hammer
        const handleGeo = new THREE.CylinderGeometry(0.5, 0.5, 8);
        const handleMat = new THREE.MeshPhongMaterial({ color: 0x8B4513 });
        const handle = new THREE.Mesh(handleGeo, handleMat);
        handle.position.y = -5.5;
        handle.rotation.x = Math.PI / 2;
        hammerHead.add(handle);
        
        // Warning indicator (red cone)
        const warnGeo = new THREE.ConeGeometry(1, 4, 8);
        const warnMat = new THREE.MeshBasicMaterial({ 
            color: 0xff0000,
            transparent: true,
            opacity: 0.7
        });
        const warning = new THREE.Mesh(warnGeo, warnMat);
        warning.position.y = -10;
        warning.rotation.x = Math.PI;
        hammerHead.add(warning);
        
        // Add to scene
        scene.add(hammerHead);
        hammerHead.position.copy(spawnPos);
        
        // Store enemy data
        const enemy = {
            mesh: hammerHead,
            position: spawnPos.clone(),
            velocity: new THREE.Vector3(0, 0, 0),
            active: true,
            impactPoint: new THREE.Vector3(spawnPos.x, 0, spawnPos.z),
            warning: warning
        };
        
        enemies.push(enemy);
        
        // Show danger indicator in UI
        showDangerWarning();
        
        // Play warning sound
        playSound('danger');
    }
    
    function updateEnemies() {
        // Update each enemy
        for (let i = enemies.length - 1; i >= 0; i--) {
            const enemy = enemies[i];
            if (!enemy.active) continue;
            
            // Apply gravity - varies with difficulty
            enemy.velocity.y -= getDifficultyValue('enemySpeed'); 
            
            // Move hammer
            enemy.position.add(enemy.velocity);
            enemy.mesh.position.copy(enemy.position);
            
            // Add spin effect
            enemy.mesh.rotation.z += 0.05;
            
            // Check for track collision using similar logic as the car
            let hitTrack = false;
            
            // Only check nearby segments for performance
            const nearbySegments = getNearbySegments(enemy.position);
            
            for (let j = 0; j < nearbySegments.length; j++) {
                let seg = nearbySegments[j];
                let segVec = new THREE.Vector3().subVectors(seg.p2, seg.p1);
                let segLen = segVec.length();
                let toEnemy = new THREE.Vector3().subVectors(enemy.position, seg.p1);
                let t = Math.max(0, Math.min(1, segVec.dot(toEnemy) / (segLen * segLen)));
                let closest = lerpVec3(seg.p1, seg.p2, t);
                let distXZ = Math.sqrt(
                    Math.pow(enemy.position.x - closest.x, 2) +
                    Math.pow(enemy.position.z - closest.z, 2)
                );
                if (distXZ < seg.width / 2) {
                    let yOnTrack = closest.y + 1.5;
                    if (enemy.position.y < yOnTrack && enemy.velocity.y < 0) {
                        // Position the hammer on the track surface
                        enemy.position.y = yOnTrack;
                        hitTrack = true;
                        break;
                    }
                }
            }
            
            // Handle impact on track or ground
            if (hitTrack || enemy.position.y < 1.5) {
                // Disable enemy
                enemy.active = false;
                
                // Create impact effect
                createImpactEffect(enemy.position.clone());
                
                // Check for collision with player
                const distToPlayer = new THREE.Vector2(enemy.position.x, enemy.position.z)
                    .distanceTo(new THREE.Vector2(carPosition.x, carPosition.z));
                
                if (distToPlayer < 6) {
                    // Hit player!
                    handleHammerHit();
                }
                
                // Remove after delay
                setTimeout(() => {
                    if (enemy.mesh && enemy.mesh.parent) {
                        scene.remove(enemy.mesh);
                        enemies.splice(enemies.indexOf(enemy), 1);
                    }
                }, 3000);
            }
        }
    }
    
    function createImpactEffect(position) {
        // Skip detailed effects in low quality mode
        if (gameSettings.quality === 'low') {
            const simpleEffect = new THREE.Mesh(
                new THREE.SphereGeometry(3, 8, 8),
                new THREE.MeshBasicMaterial({
                    color: 0xff0000,
                    transparent: true,
                    opacity: 0.5
                })
            );
            simpleEffect.position.copy(position);
            scene.add(simpleEffect);
            
            // Simple animation
            setTimeout(() => {
                scene.remove(simpleEffect);
            }, 500);
            
            return;
        }
        
        // Create dust particles
        const particleCount = 20;
        const particles = new THREE.Group();
        
        for (let i = 0; i < particleCount; i++) {
            const particleGeo = new THREE.SphereGeometry(0.3, 4, 4);
            const particleMat = new THREE.MeshBasicMaterial({
                color: 0xbbbbbb,
                transparent: true,
                opacity: 0.8
            });
            const particle = new THREE.Mesh(particleGeo, particleMat);
            
            // Random position around impact
            particle.position.x = position.x + (Math.random() * 6 - 3);
            particle.position.y = position.y + (Math.random() * 2);
            particle.position.z = position.z + (Math.random() * 6 - 3);
            
            // Random velocity
            particle.userData.velocity = new THREE.Vector3(
                Math.random() * 0.3 - 0.15,
                Math.random() * 0.2 + 0.1,
                Math.random() * 0.3 - 0.15
            );
            
            particles.add(particle);
        }
        
        scene.add(particles);
        
        // Animate particles with requestAnimationFrame for smoother motion
        const startTime = Date.now();
        function animateParticles() {
            const elapsed = Date.now() - startTime;
            if (elapsed > 2000) {
                scene.remove(particles);
                return;
            }
            
            particles.children.forEach(p => {
                p.position.add(p.userData.velocity);
                p.userData.velocity.y -= 0.01; // Gravity
                p.material.opacity -= 0.01;
            });
            
            requestAnimationFrame(animateParticles);
        }
        
        animateParticles();
        
        // Create shockwave ring
        const ringGeo = new THREE.RingGeometry(0.5, 1.5, 16);
        const ringMat = new THREE.MeshBasicMaterial({
            color: 0xffffff,
            transparent: true,
            opacity: 0.7,
            side: THREE.DoubleSide
        });
        const ring = new THREE.Mesh(ringGeo, ringMat);
        ring.position.copy(position);
        ring.position.y = 0.2;
        ring.rotation.x = -Math.PI / 2;
        scene.add(ring);
        
        // Animate expansion and fade with requestAnimationFrame
        let scale = 1;
        function expandRing() {
            scale += 0.5;
            ring.scale.set(scale, scale, scale);
            ringMat.opacity -= 0.025;
            
            if (ringMat.opacity <= 0) {
                scene.remove(ring);
                return;
            }
            
            requestAnimationFrame(expandRing);
        }
        
        expandRing();
        
        // Play impact sound
        playSound('impact');
    }
    
    function handleHammerHit() {
        // Visual effect
        carVelocity.y = 3; // Bounce up
        
        // Reduce life
        lives--;
        updateGameUI();
        
        // Play hit sound
        playSound('hammerHit');
        
        if (lives <= 0) {
            showGameOver();
        }
        
        // Visual feedback
        const feedback = document.createElement('div');
        feedback.textContent = 'SMASHED!';
        feedback.style.position = 'absolute';
        feedback.style.top = '50%';
        feedback.style.left = '50%';
        feedback.style.transform = 'translate(-50%, -50%)';
        feedback.style.color = '#ff0000';
        feedback.style.fontSize = '3em';
        feedback.style.fontWeight = 'bold';
        feedback.style.textShadow = '0 0 10px #ff0000';
        feedback.style.pointerEvents = 'none';
        feedback.style.zIndex = '20';
        document.body.appendChild(feedback);
        
        // Add screen shake effect
        const canvasContainer = document.getElementById('canvasContainer');
        let shakeIntensity = 10;
        const shakeEffect = setInterval(() => {
            canvasContainer.style.transform = `translate(${Math.random() * shakeIntensity - shakeIntensity/2}px, ${Math.random() * shakeIntensity - shakeIntensity/2}px)`;
            shakeIntensity *= 0.9;
            if (shakeIntensity < 0.5) {
                clearInterval(shakeEffect);
                canvasContainer.style.transform = 'translate(0, 0)';
            }
        }, 50);
        
        setTimeout(() => {
            document.body.removeChild(feedback);
        }, 1000);
    }
    
    function showDangerWarning() {
        const indicator = document.getElementById('dangerIndicator');
        indicator.textContent = 'DANGER INCOMING!';
        indicator.style.display = 'block';
        
        // Pulsate effect
        let opacity = 0.7;
        let increasing = false;
        const pulse = setInterval(() => {
            if (increasing) {
                opacity += 0.05;
                if (opacity >= 0.9) increasing = false;
            } else {
                opacity -= 0.05;
                if (opacity <= 0.5) increasing = true;
            }
            indicator.style.opacity = opacity;
        }, 50);
        
        setTimeout(() => {
            clearInterval(pulse);
            indicator.style.display = 'none';
        }, 2000);
    }

    // --- Sound System ---
    function initSoundSystem() {
        // Only initialize if audio is supported
        if (typeof Audio === 'undefined') {
            console.log("Audio not supported in this browser");
            return;
        }
        
        soundEnabled = true;
        
        // Create sound effects
        sounds = {
            shoot: createSound('data:audio/wav;base64,UklGRtwAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YbgAAACAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIBFqv6XQ8vFfEDWzHQ79ddlMvTiUCnq9D4g4QI0F9UiKw3RQiML2mkhCu6SGQ4JlxEdI6IgIzasMCdIsEEmV7FNJGasTSJrqEgfdJNCGnt/PBSCcy0Oh1kfCY44EQWRGgQBkv4A/pHxAP2O6QH2idwE843QCv2LyhH9'),
            collect: createSound('data:audio/wav;base64,UklGRqQDAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YYADAAAAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID///////////////////////////9/f39/f39/f39/f39/f39/f39/f3+AgICAgICAgICAgICAgICAgICAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQED///////////////////////////////////////////9/f39/f39/f39/f39/f39/f39/f3+AgICAgICAgICAgICAgICAgICAQEBAQEBAQEBAQEBAQEBAQEBAQED///////////////////////////////////////////9/f39/f39/f39/f39/f39/f39/f3+AgICAgICAgICAgICAgICAgICAQEBAQEBAQEBAQEBAQEBAQEBAQEA/Pz8/Pz8/Pz8/Pz8/Pz8/Pz8/P39/f39/f39/f39/f39/f39/f39/gICAgICAgICAgICAgICAgICAgEBAQEBAQEBAQEBAQEBAQEBAQEBAQD8/Pz8/Pz8/Pz8/Pz8/Pz8/Pz8/Pz9/f39/f39/f39/f39/f39/f39/f4CAgICAgICAgICAgICAgICAgIBAQEBAQEBAQEBAQEBAQEBAQEBAQD8/Pz8/Pz8/Pz8/Pz8/Pz8/Pz8/f39/f39/f39/f39/f39/f39/f3+AgICAgICAgICAgICAgICAgICAQEBAQEBAQEBAQEBAQEBAQEBAQEA/Pz8/Pz8/Pz8/Pz8/Pz8/Pz8/P39/f39/f39/f39/f39/f39/f39/gICAgICAgICAgICAgICAgICAgH9/f39/f39/f39/f39/f39/f39/Pz8/Pz8/Pz8/Pz8/Pz8/Pz8/Pz9/f39/f39/f39/f39/f39/f39/f4CAgICAgICAgICAgICAgICAgIB/f39/f39/f39/f39/f39/f39/fz8/Pz8/Pz8/Pz8/Pz8/Pz8/Pz8/f39/f39/f39/f39/f39/f39/f3+AgICAgICAgICAgICAgICAgICAf39/f39/f39/f39/f39/f39/f38/Pz8/Pz8/Pz8/Pz8/Pz8/Pz8/Pw=='),
            jump: createSound('data:audio/wav;base64,UklGRiwBAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQQBAAB+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fX19e3t7eHh4dHR0cHBwbGxsaGhoZGRkYGBgXFxcWFhYVFRUUFBQTExMSEhIREREQEBAPDw8ODg4NDQ0MDAwLCwsKCgoJCQkICAgHBwcGBgYFBQUEBAQDAwMCAgIBQUFAQEBAQEBBQUFCAgIDAwMEBAQFBQUGBgYHBwcICAgJCQkKCgoLCwsMDAwNDQ0ODg4PDw8QEBARERESEhITExMUFBQVFRUWFhYXFxcYGBgZGRkaGhobGxscHBwdHR0eHh4e3t7fX19fn5+fX19e3t7eHh4dHR0cHBwbGxsaGhoZGRkYGBgXFxcWFhYVFRUUFBQTExMSEhIRERE'),
            hit: createSound('data:audio/wav;base64,UklGRpAAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YXIAAAB/f35+fXx7ent5eHd3dnV0c3JycXBvbm1sa2ppaGdmZWRjYmFgX15dXFtaWVhXVlVUU1JRUE9OTUxLSklIR0ZFRENCQUA/Pj08Ozs7Ozs7PDw9PT4/QEBCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlbXF1eX2BhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ent8fX5+f4A='),
            impact: createSound('data:audio/wav;base64,UklGRrAAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YZQAAAB/f3p6dXVwcGtramZmYWFcXFhYU1NPT0tLSEhGRkREQ0NEREVFRkZISElJSUlJSUlJSUlJSUlJSUlJSUlJSUlJSUlJSUlKSkpKSkpLS0xMTU1OTk9PUFBSUlRUVlZYWFpaXFxeXmBgYmJkZGZmaGhqam1tb29xcXNzdHV2d3h5ent8fH1+f4CAgA=='),
            connected: createSound('data:audio/wav;base64,UklGRrAAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YZQAAAB/f4GBg4OFhYeHiYmLi42Nj4+RkZOTlZWXl5mZm5uenqCgpKSoqKystrS0rqyopqSioqCgnpyampiWlJKQjo2LiYeGhIKAgH5+fHx6enp6enp6fHx+foCAgIKChIaGiImLi42PkZGTlZeXmZudnaGhpaWpqa2tsLC0tLi4vLzAwMTEyMjQ0NTU2Nja3N7g4OTk6A=='),
            bonus: createSound('data:audio/wav;base64,UklGRsAAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YZQAAAB/f4CAgIGBgoKDg4SEhYWGhoeHiIiJiYmIiIiIh4eGhoWFhISDg4KCgYGAgH9/fn58fHt7enp5eXh4d3d2dnV1dHRzc3Jyc3N0dHV1dnd3eHl6ent8fH1+f4CAgYKDhIWGh4iJiouMjY6PkJGSk5SVlpeYmZqbnJ2en6ChoqOkpaanqKmqq6ytrq+wsbKztA=='),
            danger: createSound('data:audio/wav;base64,UklGRqAAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YZQAAAB/f35/e3h1dHNxcG9ubm5vb3BxcXJzdXZ3eXl6e3x9fn+AgIGBgYGBgYGBgYGBgYGBgH9/fn18e3p5eHd2dXRzcXBvbm1sa2pqaWhoaGhpaWprbG1ucHFyc3R1dnd4eXp7fH1+f4CAgYGCgoODhISFhYaGh4eIiImJioqLi4yMjY2Ojo+Pj4+QkJCQj4+OjYyLiomI'),
            land: createSound('data:audio/wav;base64,UklGRnAAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YXIAAAB/f39+fn19fHx7e3p6eXl4eHd3dnZ1dXR0c3NycnFxcXBwb29vbm5tbW1tbGxra2tqamtrbGxtbW5ub29wcHFxcnJzc3R0dXV2dnd3eHh5eXp6e3t8fH1+fn5/f4A='),
            countdown: createSound('data:audio/wav;base64,UklGRoQAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YWAAAAAAAAB/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/fw=='),
            raceStart: createSound('data:audio/wav;base64,UklGRsAAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YZQAAAB/f4CAgIGBgoKDg4SEhYWGhoeHiIiJiYqKioqLi4uLjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMi4uLi4qKiYmIiIeHhoaFhYSEg4OCgoGBgICAgICAgoKDg4WFh4eJiYuLjY2Pj5CQkZGSkpKSk5OTk5OTk5OTk5STk5KSkZGQkI+PjY2Li4mJh4eFhYOD'),
            fall: createSound('data:audio/wav;base64,UklGRrAAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YZQAAAB/f39+fn19fHx7e3p6eXl4eHd3dnZ1dXR0c3NycnFxcXBwb29vbm5tbW1tbGxra2tqamtrbGxtbW5ub29wcHFxcnJzc3R0dXV2dnd3eHh5eXp6e3t8fH19fn5/f4CAgIGBgoKDg4SEhYWGhoeHiIiJiYqKioqLi4uLjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyM'),
            finish: createSound('data:audio/wav;base64,UklGRrAAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YZQAAAB/f4CAgIGBgoKDg4SEhYWGhoeHiIiJiYqKioqLi4uLjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMi4uLi4qKiYmIiIeHhoaFhYSEg4OCgoGBgICAgICAgoKDg4WFh4eJiYuLjY2Pj5CQkZGSkpKSk5OTk5OTk5OTk5STk5KSkZGQkI+PjY2Li4mJh4eFhYOD'),
            gameOver: createSound('data:audio/wav;base64,UklGRsAAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YZQAAAB/f35+fX19fHx8e3t7e3p6enp5eXl5eHh4eHh3d3d3d3Z2dnZ2dnZ2dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV2dnZ2dnZ2dnd3d3d3d3d4eHh4eHh4eXl5eXl5eXp6enp6ent7e3t7e3x8fHx8fH19fX19fX1+fn5+fn5/f39/f39/gICAgICAgA=='),
            drift: createSound('data:audio/wav;base64,UklGRrAAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YZQAAAB/f39/f39/f39/f39/f3x8eXl2dnNzcHBtbWpqZ2dlZWJiYGBeXlxcWlpYWFZWVFRSUlBQTk5MTEpKSEhGRkREQkJAQD4+PDw6Ojg4NjY0NDMzMTEvLy4uLC0rKyoqKSkpKSgoKCgpKSkqKisrLCwtLS4uLzAxMTIzNDQ1Njc3ODk6Ojw8PT0/P0BBQkJERUZGSEhJSkxMTU5P'),
            playerJoined: createSound('data:audio/wav;base64,UklGRpAAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YXIAAAB/f39+fn59fX18fHx7e3t6enp5eXl4eHh3d3d2dnZ1dXV1dHR0dHNzc3NycnJycXFxcXBwcHBwcHBwcHBwcHBwcHBxcXFxcXJycnJzc3Nzc3R0dHR1dXV1dnZ2dnd3d3d4eHh4eXl5eXp6enp7e3t7fHx8fH19fX1+fn5+f39/fw=='),
            playerLeft: createSound('data:audio/wav;base64,UklGRpAAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YXIAAAB/f39+fn59fX18fHx7e3t6enp5eXl4eHh3d3d2dnZ1dXV1dHR0dHNzc3NycnJycXFxcXBwcHBwcHBwcHBwcHBwcHBxcXFxcXJycnJzc3Nzc3R0dHR1dXV1dnZ2dnd3d3d4eHh4eXl5eXp6enp7e3t7fHx8fH19fX1+fn5+f39/fw=='),
            spawn: createSound('data:audio/wav;base64,UklGRpAAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YXIAAAB/f39+fn59fX18fHx7e3t6enp5eXl4eHh3d3d2dnZ1dXV1dHR0dHNzc3NycnJycXFxcXBwcHBwcHBwcHBwcHBwcHBxcXFxcXJycnJzc3Nzc3R0dHR1dXV1dnZ2dnd3d3d4eHh4eXl5eXp6enp7e3t7fHx8fH19fX1+fn5+f39/fw=='),
            restart: createSound('data:audio/wav;base64,UklGRrAAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YZQAAAB/f39+fn19fHx7e3p6eXl4eHd3dnZ1dXR0c3NycnFxcXBwb29vbm5tbW1tbGxra2tqamtrbGxtbW5ub29wcHFxcnJzc3R0dXV2dnd3eHh5eXp6e3t8fH19fn5/f4CAgIGBgoKDg4SEhYWGhoeHiIiJiYqKioqLi4uLjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyM'),
            hammerHit: createSound('data:audio/wav;base64,UklGRrAAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YZQAAAB/f3+AgICAgICAf39/f39/f39/f39/f39/fn5+fn5+fn5+fn5+fn5+fn5+fn5+f39/f39/f39/f4CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgA==')
        };
    }
    
    function createSound(dataUri) {
        try {
            const sound = new Audio(dataUri);
            sound.volume = gameSettings.soundVolume / 100;
            return sound;
        } catch (e) {
            console.log("Error creating sound:", e);
            return null;
        }
    }
    
    function playSound(name) {
        if (!soundEnabled || !sounds[name] || gameSettings.soundVolume === 0) return;
        
        try {
            // Create a new Audio element for each play to allow overlapping sounds
            const sound = sounds[name].cloneNode();
            sound.volume = gameSettings.soundVolume / 100;
            sound.play().catch(e => {
                // Ignore autoplay restrictions errors
                console.log("Sound play error:", e);
            });
        } catch (e) {
            console.log("Error playing sound:", e);
        }
    }

    // --- UI and Startup ---
    function setupEventListeners() {
        document.getElementById('blockForm').onsubmit = function(e) {
            e.preventDefault();
            const blockHash = document.getElementById('blockHash').value.trim();
            if (!blockHash) return;
            joinOrCreateRoom(blockHash);
        };
        
        document.getElementById('restartGame').addEventListener('click', restartGame);
        
        // Update player name button
        document.getElementById('updateNameButton').addEventListener('click', function() {
            updatePlayerName();
        });
        
        // Refresh rooms button
        document.getElementById('refreshRooms').addEventListener('click', function() {
            updateRoomsList();
        });
        
        // Settings toggle
        document.getElementById('settingsToggle').addEventListener('click', function() {
            const panel = document.getElementById('settingsPanel');
            panel.style.display = panel.style.display === 'none' ? 'block' : 'none';
        });
        
        // Save settings button
        document.getElementById('saveSettings').addEventListener('click', function() {
            saveSettings();
        });
        
        // Setup keyboard controls
        setupControls();
    }
    
    function updatePlayerName() {
        const nameInput = document.getElementById('playerName');
        const newName = nameInput.value.trim();
        
        if (newName && newName !== playerName) {
            playerName = newName;
            
            // Save to localStorage
            localStorage.setItem('playerName', playerName);
            
            // Update car label
            if (car && car.children.length > 0) {
                // Find label (first child)
                const label = car.children[0];
                if (label && label.isSprite) {
                    // Create new label with updated name
                    const newLabel = createPlayerLabel('P' + playerIndices[playerId], playerName);
                    newLabel.position.copy(label.position);
                    newLabel.scale.copy(label.scale);
                    
                    // Replace old label
                    car.remove(label);
                    car.add(newLabel);
                }
            }
            
            // Broadcast name update
            connections.forEach(conn => {
                if (conn.open) {
                    conn.send({
                        type: 'nameUpdate',
                        playerId: playerId,
                        newName: playerName
                    });
                }
            });
            
            // Show success animation
            const success = document.getElementById('nameUpdateSuccess');
            success.style.opacity = '1';
            success.style.top = '-30px';
            
            setTimeout(() => {
                success.style.opacity = '0';
                success.style.top = '-20px';
            }, 2000);
        }
    }
    
    function saveSettings() {
        // Get values from form
        gameSettings.quality = document.getElementById('qualitySetting').value;
        gameSettings.soundVolume = parseInt(document.getElementById('soundVolume').value);
        gameSettings.showFps = document.getElementById('showFps').checked;
        gameSettings.difficulty = document.getElementById('difficultyLevel').value;
        
        // Apply settings immediately
        document.getElementById('fpsCounter').style.display = gameSettings.showFps ? 'block' : 'none';
        
        // Update sound volumes
        Object.values(sounds).forEach(sound => {
            if (sound) sound.volume = gameSettings.soundVolume / 100;
        });
        
        // Save to localStorage
        localStorage.setItem('gameSettings', JSON.stringify(gameSettings));
        
        // Close panel
        document.getElementById('settingsPanel').style.display = 'none';
        
        // Show success message
        const message = document.createElement('div');
        message.textContent = 'Settings saved!';
        message.style.position = 'fixed';
        message.style.top = '20%';
        message.style.left = '50%';
        message.style.transform = 'translate(-50%, -50%)';
        message.style.background = 'rgba(0,255,0,0.7)';
        message.style.color = 'white';
        message.style.padding = '10px 20px';
        message.style.borderRadius = '5px';
        message.style.zIndex = '100';
        document.body.appendChild(message);
        
        setTimeout(() => {
            document.body.removeChild(message);
        }, 2000);
    }
    
    function loadSettings() {
        // Load from localStorage if available
        const savedSettings = localStorage.getItem('gameSettings');
        if (savedSettings) {
            try {
                const parsed = JSON.parse(savedSettings);
                gameSettings = { ...gameSettings, ...parsed };
            } catch (e) {
                console.error("Error parsing saved settings:", e);
            }
        }
        
        // Apply settings to form
        document.getElementById('qualitySetting').value = gameSettings.quality;
        document.getElementById('soundVolume').value = gameSettings.soundVolume;
        document.getElementById('showFps').checked = gameSettings.showFps;
        document.getElementById('difficultyLevel').value = gameSettings.difficulty;
        
        // Apply settings
        document.getElementById('fpsCounter').style.display = gameSettings.showFps ? 'block' : 'none';
    }

    window.onload = function() {
        initThreeJS();
        updateGameUI();
        initSoundSystem();
        setupEventListeners();
        loadSettings();
        setInterval(updateRoomsList, 3000);   // ← refresh room list live
        
        // Get player name from localStorage if available
        const savedName = localStorage.getItem('playerName');
        if (savedName) {
            document.getElementById('playerName').value = savedName;
            playerName = savedName;
        }
        
        // Detect mobile and show controls if needed
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        if (isMobile) {
            document.getElementById('mobileControls').style.display = 'block';
            document.getElementById('instructions').innerHTML = '<b>Use on-screen controls</b> to drive. Tap to Jump, Boost, Drift, and Shoot!';
        }
        
        // Fetch latest block more robustly
        fetchLatestBlockInfo().then(block => {
            if (block) {
                animate(); // Start animation after block is loaded
                joinOrCreateRoom(block); // Join game with latest block
            } else {
                // Use a default block if all else fails
                const defaultBlock = '783000';
                document.getElementById('blockHash').value = defaultBlock;
                animate();
                joinOrCreateRoom(defaultBlock);
            }
        }).catch(error => {
            console.error("Error in block loading:", error);
            // Fallback to default block
            const defaultBlock = '783000';
            document.getElementById('blockHash').value = defaultBlock;
            animate();
            joinOrCreateRoom(defaultBlock);
        });
    };
    </script>
</body>
</html>
