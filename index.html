<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>3DBitmap Driving Game</title>
    <style>
        html, body {
            height: 100%;
            margin: 0;
            background: #181818;
            color: #fff;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
        }
        #canvasContainer {
            position: absolute;
            top: 0; left: 0; width: 100vw; height: 100vh;
            background: #181818;
            z-index: 1;
        }
        #uiBar {
            position: absolute;
            top: 0; left: 0; width: 100vw;
            background: rgba(24,24,24,0.95);
            color: #ffa94d;
            padding: 8px 16px;
            z-index: 10;
            display: flex;
            align-items: center;
            gap: 18px;
            font-size: 1.1em;
        }
        #blockForm input[type="text"] {
            padding: 6px 10px;
            border-radius: 4px 0 0 4px;
            border: 1px solid #ffa94d;
            outline: none;
            font-size: 1em;
            width: 120px;
        }
        #blockForm button {
            padding: 6px 12px;
            border-radius: 0 4px 4px 0;
            border: none;
            background: #ffa94d;
            color: #181818;
            font-weight: bold;
            cursor: pointer;
            font-size: 1em;
        }
        #blockInfo {
            margin-left: 24px;
            font-size: 0.95em;
            color: #fff;
        }
        #loadingOverlay {
            position: fixed;
            top:0; left:0; width:100vw; height:100vh;
            background: rgba(16,16,24,0.95);
            color: #ffa94d;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 100;
            font-size: 1.3em;
            letter-spacing: 1px;
        }
        #loadingBar {
            width: 240px;
            height: 10px;
            background: #222;
            border-radius: 5px;
            margin-top: 18px;
            overflow: hidden;
        }
        #loadingBarProgress {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg,#f7931a,#ffa94d);
            transition: width 0.2s;
        }
        #instructions {
            position: absolute;
            bottom: 16px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(24,24,24,0.85);
            color: #ffa94d;
            padding: 8px 18px;
            border-radius: 8px;
            font-size: 1em;
            z-index: 10;
            pointer-events: none;
        }
        #minimap {
            position: absolute;
            bottom: 16px;
            right: 16px;
            width: 200px;
            height: 200px;
            background: rgba(0,0,0,0.7);
            border: 2px solid #ffa94d;
            border-radius: 4px;
            overflow: hidden;
            z-index: 10;
        }
        .otherPlayerMarker {
            position: absolute;
            width: 6px;
            height: 6px;
            margin-left: -3px;
            margin-top: -3px;
            border-radius: 50%;
            border: 1px solid #fff;
        }
        .playerMarker {
            position: absolute;
            width: 8px;
            height: 8px;
            margin-left: -4px;
            margin-top: -4px;
            border-radius: 50%;
            border: 1px solid #fff;
            background: #ff0;
        }
        #gameUI {
            position: absolute;
            top: 50px;
            left: 16px;
            background: rgba(24,24,24,0.85);
            color: #ffa94d;
            padding: 8px 18px;
            border-radius: 8px;
            font-size: 1em;
            z-index: 10;
        }
        #gameUI .lives {
            font-size: 1.5em;
            color: #ff3333;
        }
        #gameUI .boost {
            margin-top: 5px;
            height: 8px;
            width: 100px;
            background: rgba(255,255,255,0.2);
            border-radius: 4px;
        }
        #gameUI .boost-bar {
            height: 100%;
            width: 100%;
            background: linear-gradient(90deg, #3366ff, #00ccff);
            border-radius: 4px;
            transition: width 0.2s;
        }
        #gameUI .score {
            margin-top: 5px;
            font-weight: bold;
        }
        #gameOverScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0,0,0,0.85);
            color: #ffa94d;
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 200;
        }
        #gameOverScreen h2 {
            font-size: 3em;
            margin-bottom: 20px;
        }
        #gameOverScreen button {
            padding: 10px 20px;
            border-radius: 5px;
            border: none;
            background: #ffa94d;
            color: #181818;
            font-weight: bold;
            font-size: 1.2em;
            cursor: pointer;
            margin-top: 20px;
        }
        .collectible {
            position: absolute;
            width: 30px;
            height: 30px;
            margin-left: -15px;
            margin-top: -15px;
            border-radius: 50%;
            background: radial-gradient(#ffcc00, #ff6600);
            box-shadow: 0 0 15px #ffcc00;
            animation: pulse 1s infinite alternate;
        }
        @keyframes pulse {
            from { transform: scale(1); }
            to { transform: scale(1.2); }
        }
        #raceControls {
            position: absolute;
            top: 48px;
            right: 16px;
            background: rgba(24,24,24,0.85);
            color: #ffa94d;
            padding: 10px;
            border-radius: 8px;
            z-index: 10;
            width: 220px;
            text-align: center;
        }
        #raceControls button {
            padding: 8px 16px;
            border-radius: 4px;
            border: none;
            background: #ffa94d;
            color: #181818;
            font-weight: bold;
            cursor: pointer;
            margin: 5px;
            font-size: 1em;
        }
        #countdown {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 8em;
            color: #ffa94d;
            font-weight: bold;
            text-shadow: 0 0 20px rgba(255, 169, 77, 0.8);
            z-index: 50;
            display: none;
        }
        .startLine, .finishLine {
            position: absolute;
            left: 0;
            width: 100%;
            height: 5px;
            background: repeating-linear-gradient(
                90deg,
                #fff,
                #fff 20px,
                #000 20px,
                #000 40px
            );
            z-index: 5;
        }
        .startLine {
            background: repeating-linear-gradient(
                90deg,
                #fff,
                #fff 20px,
                #00ff00 20px,
                #00ff00 40px
            );
        }
        .finishLine {
            background: repeating-linear-gradient(
                90deg,
                #fff,
                #fff 20px,
                #ff0000 20px,
                #ff0000 40px
            );
        }
        #nameInputContainer {
            position: fixed;
            top: 16px;
            right: 50%;
            transform: translateX(50%);
            background: rgba(24,24,24,0.85);
            color: #ffa94d;
            padding: 8px 18px;
            border-radius: 8px;
            z-index: 15;
            text-align: center;
        }
        
        #playerName {
            padding: 6px 10px;
            border-radius: 4px;
            border: 1px solid #ffa94d;
            background: #333;
            color: #fff;
            font-size: 1em;
            text-align: center;
            width: 150px;
        }
        
        .dangerIndicator {
            position: absolute;
            top: 20%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #ff0000;
            font-size: 3em;
            font-weight: bold;
            text-shadow: 0 0 10px rgba(255, 0, 0, 0.8);
            animation: pulse 0.5s infinite alternate;
            z-index: 20;
            display: none;
            background: rgba(0,0,0,0.5);
            padding: 10px 20px;
            border-radius: 8px;
        }

        #jumpIndicator {
            position: absolute;
            bottom: 60px;
            left: 16px;
            background: rgba(24,24,24,0.85);
            color: #00aaff;
            padding: 5px 10px;
            border-radius: 8px;
            font-size: 0.9em;
            z-index: 10;
        }
        
        #jumpIndicator.cooldown {
            color: #777;
        }

        /* Mobile Controls */
        #mobileControls {
            position: fixed;
            bottom: 70px;
            left: 0;
            width: 100%;
            display: none;  /* Hidden by default, shown on mobile */
            z-index: 20;
        }
        
        .control-button {
            width: 60px;
            height: 60px;
            background: rgba(255, 169, 77, 0.7);
            color: #fff;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            font-weight: bold;
            user-select: none;
            border: 2px solid rgba(255, 255, 255, 0.7);
        }
        
        .control-button.active {
            background: rgba(255, 169, 77, 1);
            transform: scale(0.95);
        }
        
        #directionalPad {
            position: fixed;
            bottom: 100px;
            left: 20px;
            display: grid;
            grid-template-columns: 60px 60px 60px;
            grid-template-rows: 60px 60px 60px;
            gap: 5px;
        }
        
        #actionButtons {
            position: fixed;
            bottom: 100px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        .action-row {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
        }
        
        .button-up { grid-column: 2; grid-row: 1; }
        .button-left { grid-column: 1; grid-row: 2; }
        .button-right { grid-column: 3; grid-row: 2; }
        .button-down { grid-column: 2; grid-row: 3; }
        
        /* Shooting related styles */
        .laser-beam {
            position: absolute;
            height: 2px;
            background: linear-gradient(90deg, rgba(255,0,0,0) 0%, rgba(255,0,0,1) 50%, rgba(255,0,0,0) 100%);
            transform-origin: center left;
            z-index: 5;
        }
        
        .hit-effect {
            position: absolute;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(255,0,0,1) 0%, rgba(255,0,0,0) 70%);
            z-index: 5;
            pointer-events: none;
        }
        
        #scorePopup {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #ffcc00;
            font-size: 2.5em;
            font-weight: bold;
            text-shadow: 0 0 10px rgba(255, 204, 0, 0.8);
            z-index: 30;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s, transform 0.7s;
        }
        
        #updateNameButton {
            padding: 6px 10px;
            border-radius: 4px;
            border: 1px solid #ffa94d;
            background: #333;
            color: #fff;
            font-size: 1em;
            margin-left: 5px;
            cursor: pointer;
        }
        
        #nameUpdateSuccess {
            position: absolute;
            top: -20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,255,0,0.7);
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 0.9em;
            opacity: 0;
            transition: opacity 0.5s, top 0.5s;
        }
        
        /* Cooldown indicator for shooting */
        #shootCooldown {
            position: absolute;
            bottom: 60px;
            right: 16px;
            background: rgba(24,24,24,0.85);
            color: #ff3333;
            padding: 5px 10px;
            border-radius: 8px;
            font-size: 0.9em;
            z-index: 10;
        }
        
        #shootCooldown.ready {
            color: #33ff33;
        }
        
        /* Enhanced collectibles */
        .collectible-target {
            position: absolute;
            width: 40px;
            height: 40px;
            margin-left: -20px;
            margin-top: -20px;
            border-radius: 50%;
            border: 2px dashed rgba(255, 204, 0, 0.7);
            animation: rotate 10s linear infinite;
        }
        
        @keyframes rotate {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div id="canvasContainer"></div>
    <div id="uiBar">
        <form id="blockForm" style="display:inline-flex;">
            <input type="text" id="blockHash" value="676767" placeholder="Block # or hash">
            <button type="submit">Load</button>
        </form>
        <span id="blockInfo">Block: <span id="blockHeight">-</span> | TX: <span id="txCount">-</span> | BTC: <span id="totalBtc">-</span> | <span id="blockTime">-</span></span>
    </div>
    <div id="instructions">
        <b>Arrow keys</b> to drive. <b>Space</b> to jump. <b>Shift</b> to boost. <b>D</b> to drift. <b>Load a block</b> to generate a new track!
    </div>
    <div id="loadingOverlay" style="display:none;">
        <div id="loadingText">Loading block data...</div>
        <div id="loadingBar"><div id="loadingBarProgress"></div></div>
    </div>
    <div id="minimap"></div>
    <div id="gameUI">
        <div>Lives: <span class="lives">❤️❤️❤️</span></div>
        <div>Boost: <div class="boost"><div class="boost-bar"></div></div></div>
        <div class="score">Score: 0</div>
    </div>
    <div id="gameOverScreen">
        <h2>GAME OVER</h2>
        <div class="final-score">Score: 0</div>
        <button id="restartGame">Try Again</button>
    </div>
    <div id="raceControls" style="display: none;">
        <h3 style="margin-top:0">Race Controls</h3>
        <button id="startRaceButton">Start Race</button>
        <div id="connectedPlayers">
            <p>Connected players: <span id="playerCount">0</span></p>
        </div>
        <div id="playersList" style="max-height: 150px; overflow-y: auto; margin-top: 10px; text-align: left; font-size: 0.9em;"></div>
    </div>
    <div id="countdown"></div>
    <div id="nameInputContainer">
        <label for="playerName">Your Name: </label>
        <input type="text" id="playerName" maxlength="15" placeholder="Enter name">
    </div>
    <div id="dangerIndicator" class="dangerIndicator">⚠️ DANGER!</div>
    <div id="jumpIndicator">Jump Ready</div>
    <script src="https://unpkg.com/peerjs@1.4.7/dist/peerjs.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
    // --- Minimal Block Data Fetch ---
    let storedTransactions = [];
    let blockMetadata = null;
    let cachedBlockHash = null; // cache the loaded block hash
    let controlsLocked = false; // For race start countdown, prevents movement
    let playerName = "Player";
    let enemies = [];
    let enemySpawnInterval = null;

    async function loadBlockData(blockHash) {
        // Only fetch and reload if not already loaded
        if (cachedBlockHash === blockHash && storedTransactions.length && blockMetadata) {
            showLoading(false, 100, "Block already loaded");
            return;
        }
        showLoading(true, 0, "Loading block data...");
        try {
            const apiUrl = `https://blockchain.info/rawblock/${blockHash}?cors=true`;
            const response = await fetch(apiUrl);
            if (!response.ok) throw new Error("Block not found");
            showLoading(true, 30, "Parsing block data...");
            const data = await response.json();
            storedTransactions = data.tx || [];
            blockMetadata = {
                height: data.height,
                hash: data.hash,
                time: data.time,
                tx_count: data.tx ? data.tx.length : 0
            };
            showLoading(true, 60, "Generating track...");
            updateBlockInfo(blockMetadata);
            createDrivingTrack(storedTransactions);
            if (respawnPoint) {
                carPosition.copy(respawnPoint.pos);
                carAngle = respawnPoint.angle;
                carVelocity.set(0, 0, 0);
                carSpeed = 0;
                raceFinished = false;
                finishLinePassed = false;
            }
            showLoading(false, 100, "Done");
            cachedBlockHash = blockHash;
        } catch (e) {
            showLoading(true, 100, "Error: " + e.message);
            setTimeout(()=>showLoading(false), 1200);
        }
    }

    async function fetchLatestBlockInfo() {
        showLoading(true, 0, "Fetching latest block info...");
        try {
            // Try multiple API sources with a CORS proxy
            const corsProxy = 'https://cors-anywhere.herokuapp.com/';
            let response;
            
            try {
                // First try with mempool.space API which is more CORS friendly
                response = await fetch('https://mempool.space/api/blocks/tip/height');
                if (response.ok) {
                    const blockHeight = await response.text();
                    document.getElementById('blockHash').value = blockHeight;
                    showLoading(false);
                    return blockHeight;
                }
            } catch (err) {
                console.log("Mempool API failed, trying alternative...");
            }
            
            try {
                // Try with cors-anywhere proxy as fallback
                response = await fetch(corsProxy + 'https://blockchain.info/latestblock');
                if (response.ok) {
                    const data = await response.json();
                    document.getElementById('blockHash').value = data.hash || data.height;
                    showLoading(false);
                    return data.hash || data.height;
                }
            } catch (err) {
                console.log("Proxy API attempt failed...");
            }
            
            // If all fail, use a fallback block
            const fallbackBlock = '783000'; // A recent block height that works
            console.log("Using fallback block:", fallbackBlock);
            document.getElementById('blockHash').value = fallbackBlock;
            showLoading(false);
            return fallbackBlock;
        } catch (e) {
            console.error("Error fetching latest block:", e);
            const fallbackBlock = '783000';
            document.getElementById('blockHash').value = fallbackBlock;
            showLoading(false);
            return fallbackBlock;
        }
    }

    function updateBlockInfo(meta) {
        document.getElementById('blockHeight').textContent = meta.height || '-';
        document.getElementById('txCount').textContent = meta.tx_count || '-';
        let totalBtc = 0;
        if (storedTransactions && storedTransactions.length > 0) {
            storedTransactions.forEach(tx => {
                if (tx.out && Array.isArray(tx.out)) {
                    tx.out.forEach(output => { totalBtc += output.value || 0; });
                }
            });
            totalBtc = (totalBtc / 100000000).toFixed(8);
        }
        document.getElementById('totalBtc').textContent = totalBtc || '-';
        document.getElementById('blockTime').textContent = meta.time ? new Date(meta.time * 1000).toLocaleString() : '-';
    }

    function showLoading(show, percent, text) {
        const overlay = document.getElementById('loadingOverlay');
        overlay.style.display = show ? 'flex' : 'none';
        if (typeof percent === 'number') {
            document.getElementById('loadingBarProgress').style.width = percent + "%";
        }
        if (text) document.getElementById('loadingText').textContent = text;
    }

    // --- Driving Game Logic ---
    let scene, camera, renderer;
    let trackSegments = [];
    let car, carSpeed = 0, carMaxSpeed = 2.5, carSteer = 0, carAngle = 0;
    let carPosition = new THREE.Vector3(0, 5, 0);
    let carVelocity = new THREE.Vector3(0, 0, 0);
    let carDirection = new THREE.Vector3(0, 0, 1);
    let carOnGround = false;
    let cameraOffset = new THREE.Vector3(0, 10, -22);
    let keys = {};
    let gravity = -0.25;
    let friction = 0.98;
    let groundFriction = 0.92;
    let jumpPower = 0.0; // set to >0 for jump support
    let trackWidth = 16; // Increased width for easier driving
    let respawnPoint = null;

    // Game mechanics variables
    let lives = 3;
    let fallCount = 0;
    let gameOver = false;
    let score = 0;
    let boostAmount = 100;
    let boostRechargeRate = 0.5;
    let boostDepletionRate = 1;
    let collectibles = [];
    let collectibleCount = 0;

    // Race management variables
    let raceActive = false;
    let raceFinished = false;
    let raceStartTime = 0;
    let startLineObj = null;
    let finishLineObj = null;
    let finishLinePassed = false;
    let raceTimes = {}; // Store player finish times

    // Special abilities
    let canJump = true;
    let jumpCooldown = 1500; // milliseconds
    let boostStrength = 1.0;  // Multiplier for boost
    let driftFactor = 0.0;   // For drift mode (0 = no drift)

    // Helper for smooth track connection (Catmull-Rom spline)
    function smoothTrackPoints(points) {
        // Adjust hills so there are no step ups/downs: smooth y between points
        // We'll use a moving average to smooth the y values
        let yVals = points.map(p => p.p1.y);
        let smoothYs = [];
        for (let i = 0; i < yVals.length; i++) {
            let sum = 0, count = 0;
            for (let j = -2; j <= 2; j++) {
                if (i + j >= 0 && i + j < yVals.length) {
                    sum += yVals[i + j];
                    count++;
                }
            }
            smoothYs[i] = sum / count;
        }
        // Set all p1.y and p2.y to the smoothed value for both ends of each segment
        for (let i = 0; i < points.length; i++) {
            points[i].p1.y = smoothYs[i];
            if (i < points.length - 1) {
                points[i].p2.y = smoothYs[i + 1];
            } else {
                points[i].p2.y = smoothYs[i];
            }
        }

        // Use CatmullRomCurve3 for smooth interpolation
        let curvePoints = points.map(p => p.p1.clone());
        curvePoints.push(points[points.length - 1].p2.clone());
        let curve = new THREE.CatmullRomCurve3(curvePoints, false, 'catmullrom', 0.5);
        let smooth = [];
        let N = points.length * 8;
        for (let i = 0; i < N; i++) {
            let t1 = i / N;
            let t2 = (i + 1) / N;
            let p1 = curve.getPoint(t1);
            let p2 = curve.getPoint(t2);
            let idx = Math.floor(t1 * points.length);
            let width = points[idx] ? points[idx].width : trackWidth;
            smooth.push({ p1, p2, width });
        }
        return smooth;
    }

    // --- ThreeJS Initialization ---
    function initThreeJS() {
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
        camera.position.set(0, 10, -30);
        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.getElementById('canvasContainer').appendChild(renderer.domElement);

        // Lighting
        scene.add(new THREE.AmbientLight(0x888888));
        let dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(10, 30, 10);
        scene.add(dirLight);

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    }

    // Helper for smooth track connection
    function lerpVec3(a, b, t) {
        return new THREE.Vector3(
            a.x + (b.x - a.x) * t,
            a.y + (b.y - a.y) * t,
            a.z + (b.z - a.z) * t
        );
    }

    // Generate flat track with smooth hills and turns
    function createDrivingTrack(transactions) {
        clearScene();
        trackSegments = [];
        let points = [];
        let pos = new THREE.Vector3(0, 0, 0);
        let angleY = 0;

        // 1. Generate points for each segment
        transactions.forEach((tx, i) => {
            let hashVal = parseInt(tx.hash.slice(-2), 16);
            let type = hashVal % 3; // 0: straight, 1: left, 2: right
            let length = 20 + ((tx.out ? tx.out.length : 1) * 5);
            let width = trackWidth;
            // Hill height based on tx value
            let value = tx.out ? tx.out.reduce((acc, cur) => acc + (cur.value || 0), 0) : 0;
            let hill = ((value / 1e8) % 1) * 12 - 6; // -6 to +6

            // Angle based on hash
            if (type === 1) angleY += Math.PI / 12;
            if (type === 2) angleY -= Math.PI / 12;

            // Next point
            let next = new THREE.Vector3(
                pos.x + Math.sin(angleY) * length,
                hill,
                pos.z + Math.cos(angleY) * length
            );
            points.push({ p1: pos.clone(), p2: next.clone(), width, angleY });
            pos = next;
        });

        // Smooth the track (no step up/downs)
        let smoothSegments = smoothTrackPoints(points);

        // Create segments
        for (let i = 0; i < smoothSegments.length; i++) {
            let { p1, p2, width } = smoothSegments[i];
            let segLen = p1.distanceTo(p2);
            let mid = lerpVec3(p1, p2, 0.5);
            let boxGeom = new THREE.BoxGeometry(width, 2, segLen);
            let color = 0x222222 + (i * 1000);
            let mat = new THREE.MeshPhongMaterial({ color: color });
            let mesh = new THREE.Mesh(boxGeom, mat);

            mesh.position.copy(mid);
            let dx = p2.x - p1.x, dz = p2.z - p1.z;
            mesh.rotation.y = Math.atan2(dx, dz);
            let dy = p2.y - p1.y;
            mesh.rotation.x = Math.atan2(dy, segLen);

            scene.add(mesh);
            trackSegments.push({ mesh, p1: p1.clone(), p2: p2.clone(), width, segLen });
        }

        // Place car at start
        createCar(smoothSegments[0].p1, Math.atan2(
            smoothSegments[0].p2.x - smoothSegments[0].p1.x,
            smoothSegments[0].p2.z - smoothSegments[0].p1.z
        ));
        // Store track points for collision
        trackSegments.trackPoints = smoothSegments;
        // Set respawn point to start
        respawnPoint = {
            pos: smoothSegments[0].p1.clone(),
            angle: Math.atan2(
                smoothSegments[0].p2.x - smoothSegments[0].p1.x,
                smoothSegments[0].p2.z - smoothSegments[0].p1.z
            )
        };

        // Re-add other players' meshes so they persist
        Object.values(otherPlayers).forEach(p => {
            scene.add(p.mesh);
        });

        // Reset game state for new track
        lives = 3;
        fallCount = 0;
        gameOver = false;
        score = 0;
        boostAmount = 100;
        updateGameUI();

        // Spawn collectibles on the new track
        spawnCollectibles();

        // Create start and finish lines
        createStartAndFinishLines(trackSegments);

        // Reset race state
        raceActive = false;
        raceFinished = false;
        finishLinePassed = false;
    }

    function createCar(startPos, startAngle) {
        if (car) scene.remove(car);
        let geometry = new THREE.BoxGeometry(3, 2, 5);
        // Convert player color hex to number
        const colorNum = parseInt(playerColor.replace('#', '0x'), 16);
        let material = new THREE.MeshPhongMaterial({ 
            color: colorNum,
            emissive: new THREE.Color(colorNum).multiplyScalar(0.2) 
        });
        car = new THREE.Mesh(geometry, material);
        car.position.copy(startPos || new THREE.Vector3(0, 5, 0));
        car.rotation.y = startAngle || 0;
        
        // Add self label
        const label = createPlayerLabel('P' + playerIndices[playerId], playerName);
        car.add(label);
        
        scene.add(car);
        carSpeed = 0;
        carAngle = startAngle || 0;
        carPosition.copy(car.position);
        carVelocity.set(0, 0, 0);
        carDirection.set(Math.sin(carAngle), 0, Math.cos(carAngle));
        
        // Initialize minimap
        initMinimap();
    }

    window.addEventListener('keydown', e => { 
        keys[e.code] = true;
        
        // Prevent scrolling and other browser defaults
        if(['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'ShiftLeft', 'Space', 'KeyD'].includes(e.code)) {
            e.preventDefault();
        }
    });
    
    window.addEventListener('keyup', e => { 
        keys[e.code] = false;
    });

    function updateGameUI() {
        // Update lives display
        const livesDisplay = document.querySelector('#gameUI .lives');
        const hearts = '❤️'.repeat(lives);
        livesDisplay.textContent = hearts;
        
        // Update boost bar
        const boostBar = document.querySelector('#gameUI .boost-bar');
        boostBar.style.width = boostAmount + '%';
        
        // Update score
        document.querySelector('#gameUI .score').textContent = 'Score: ' + score;
    }
    
    function showGameOver() {
        document.getElementById('gameOverScreen').style.display = 'flex';
        document.querySelector('#gameOverScreen .final-score').textContent = 'Score: ' + score;
        gameOver = true;
    }
    
    function restartGame() {
        // Reset game variables
        lives = 3;
        fallCount = 0;
        gameOver = false;
        score = 0;
        boostAmount = 100;
        
        // Reset car position to start
        if (respawnPoint) {
            carPosition.copy(respawnPoint.pos);
            carAngle = respawnPoint.angle;
        } else {
            carPosition.set(0, 5, 0);
            carAngle = 0;
        }
        carVelocity.set(0, 0, 0);
        carSpeed = 0;
        
        // Hide game over screen
        document.getElementById('gameOverScreen').style.display = 'none';
        
        // Update UI
        updateGameUI();
        
        // Spawn collectibles
        spawnCollectibles();
    }
    
    // Collectible items implementation
    function spawnCollectibles() {
        // Remove existing collectibles
        collectibles.forEach(c => {
            if (c.object && c.object.parent) c.object.parent.remove(c.object);
        });
        collectibles = [];
        
        // Only spawn if we have track segments
        if (!trackSegments || trackSegments.length < 2) return;
        
        // Place collectibles along the track
        const numCollectibles = Math.min(20, trackSegments.length / 2);
        
        for (let i = 0; i < numCollectibles; i++) {
            // Get a random track segment (not the first or last)
            const segIdx = Math.floor(Math.random() * (trackSegments.length - 2)) + 1;
            const seg = trackSegments[segIdx];
            
            // Random position along segment
            const t = Math.random();
            const pos = lerpVec3(seg.p1, seg.p2, t);
            pos.y += 3; // float above track
            
            // Create collectible object
            const geometry = new THREE.SphereGeometry(1, 8, 8);
            const material = new THREE.MeshBasicMaterial({
                color: 0xffcc00,
                transparent: true,
                opacity: 0.8
            });
            const sphere = new THREE.Mesh(geometry, material);
            
            // Add glow effect
            const glowGeo = new THREE.SphereGeometry(1.5, 8, 8);
            const glowMat = new THREE.MeshBasicMaterial({
                color: 0xffcc00,
                transparent: true,
                opacity: 0.4
            });
            const glow = new THREE.Mesh(glowGeo, glowMat);
            sphere.add(glow);
            
            scene.add(sphere);
            
            collectibles.push({
                object: sphere,
                position: pos,
                collected: false,
                value: Math.floor(Math.random() * 50) + 10
            });
        }
        
        collectibleCount = numCollectibles;
    }
    
    function checkCollectibleCollision() {
        if (!carPosition) return;
        
        collectibles.forEach(item => {
            if (!item.collected && item.object) {
                const distance = carPosition.distanceTo(item.position);
                if (distance < 3) {
                    // Collect the item
                    item.collected = true;
                    scene.remove(item.object);
                    
                    // Add to score
                    score += item.value;
                    
                    // Add to boost
                    boostAmount = Math.min(100, boostAmount + 20);
                    
                    // Visual feedback
                    const feedback = document.createElement('div');
                    feedback.textContent = '+' + item.value;
                    feedback.style.position = 'absolute';
                    feedback.style.top = '50%';
                    feedback.style.left = '50%';
                    feedback.style.transform = 'translate(-50%, -50%)';
                    feedback.style.color = '#ffcc00';
                    feedback.style.fontSize = '2em';
                    feedback.style.fontWeight = 'bold';
                    feedback.style.textShadow = '0 0 10px #ff6600';
                    feedback.style.pointerEvents = 'none';
                    feedback.style.transition = 'all 1s';
                    feedback.style.opacity = '1';
                    document.body.appendChild(feedback);
                    
                    // Animate and remove feedback
                    setTimeout(() => {
                        feedback.style.opacity = '0';
                        feedback.style.transform = 'translate(-50%, -100%)';
                        setTimeout(() => document.body.removeChild(feedback), 1000);
                    }, 100);
                    
                    // Update UI
                    updateGameUI();
                }
            }
        });
    }

    function updateCar() {
        if (gameOver) return;
        
        // Only allow controls when not locked
        if (!controlsLocked) {
            // Car controls (arcade style)
            if (keys['ArrowUp']) carSpeed = Math.min(carSpeed + 0.08, carMaxSpeed);
            else carSpeed = Math.max(carSpeed - 0.04, 0);
            if (keys['ArrowLeft']) carAngle += (0.045 + driftFactor) * (carSpeed / carMaxSpeed + 0.5);
            if (keys['ArrowRight']) carAngle -= (0.045 + driftFactor) * (carSpeed / carMaxSpeed + 0.5);

            // Jump control - Space bar
            if (keys['Space'] && canJump && carOnGround) {
                carVelocity.y = 6; // Jump power
                carOnGround = false;
                canJump = false;
                
                // Visual feedback for jump
                const jumpFeedback = document.createElement('div');
                jumpFeedback.textContent = 'JUMP!';
                jumpFeedback.style.position = 'absolute';
                jumpFeedback.style.top = '40%';
                jumpFeedback.style.left = '50%';
                jumpFeedback.style.transform = 'translate(-50%, -50%)';
                jumpFeedback.style.color = '#00aaff';
                jumpFeedback.style.fontSize = '2em';
                jumpFeedback.style.fontWeight = 'bold';
                jumpFeedback.style.zIndex = '15';
                document.body.appendChild(jumpFeedback);
                
                setTimeout(() => {
                    document.body.removeChild(jumpFeedback);
                    // Reset jump cooldown
                    setTimeout(() => { canJump = true; }, jumpCooldown);
                }, 500);
            }

            // Boost control with enhanced strength
            if (keys['ShiftLeft'] && boostAmount > 0) {
                carSpeed = Math.min(carSpeed + 0.15 * boostStrength, carMaxSpeed * 1.5 * boostStrength);
                boostAmount = Math.max(0, boostAmount - boostDepletionRate);
                updateGameUI();
            } else if (boostAmount < 100) {
                // Recharge boost when not using
                boostAmount = Math.min(100, boostAmount + boostRechargeRate);
                updateGameUI();
            }
            
            // Drift mode toggle with 'D' key
            if (keys['KeyD'] && !keys.KeyD_previous) {
                driftFactor = driftFactor > 0 ? 0 : 0.03;
                const driftMsg = document.createElement('div');
                driftMsg.textContent = driftFactor > 0 ? 'DRIFT MODE: ON' : 'DRIFT MODE: OFF';
                driftMsg.style.position = 'absolute';
                driftMsg.style.bottom = '120px';
                driftMsg.style.left = '50%';
                driftMsg.style.transform = 'translateX(-50%)';
                driftMsg.style.color = '#ff00ff';
                driftMsg.style.fontSize = '1.5em';
                driftMsg.style.fontWeight = 'bold';
                driftMsg.style.zIndex = '15';
                driftMsg.style.background = 'rgba(0,0,0,0.5)';
                driftMsg.style.padding = '5px 15px';
                driftMsg.style.borderRadius = '10px';
                document.body.appendChild(driftMsg);
                setTimeout(() => document.body.removeChild(driftMsg), 1500);
            }
            keys.KeyD_previous = keys['KeyD'];
        } else {
            // When controls are locked, slow down
            carSpeed = Math.max(carSpeed - 0.08, 0);
        }

        // Update direction
        carDirection.set(Math.sin(carAngle), 0, Math.cos(carAngle)).normalize();

        // Apply forward movement
        carVelocity.x = carDirection.x * carSpeed;
        carVelocity.z = carDirection.z * carSpeed;

        // Gravity
        carVelocity.y += gravity;

        // Move car
        carPosition.add(carVelocity);

        // Track collision: find closest segment below car, and set y if on track
        carOnGround = false;
        let minDist = 99999, groundY = null, groundNormal = new THREE.Vector3(0,1,0);
        let groundAngle = 0;
        let closestSegIdx = -1;
        let closestT = 0;
        for (let i = 0; i < trackSegments.length; i++) {
            let seg = trackSegments[i];
            let segVec = new THREE.Vector3().subVectors(seg.p2, seg.p1);
            let segLen = segVec.length();
            let toCar = new THREE.Vector3().subVectors(carPosition, seg.p1);
            let t = Math.max(0, Math.min(1, segVec.dot(toCar) / (segLen * segLen)));
            let closest = lerpVec3(seg.p1, seg.p2, t);
            let distXZ = Math.sqrt(
                Math.pow(carPosition.x - closest.x, 2) +
                Math.pow(carPosition.z - closest.z, 2)
            );
            if (distXZ < seg.width / 2 + 1) {
                let yOnTrack = closest.y + 1.5;
                let yDiff = carPosition.y - yOnTrack;
                
                // Modified condition to prevent falling through track when landing
                // Check if car is above track and moving downward
                if (yDiff > -2 && Math.abs(yDiff) < minDist) {
                    minDist = Math.abs(yDiff);
                    groundY = yOnTrack;
                    groundNormal = new THREE.Vector3(
                        (seg.p2.y - seg.p1.y) / segLen * segVec.x / segLen,
                        1,
                        (seg.p2.y - seg.p1.y) / segLen * segVec.z / segLen
                    ).normalize();
                    groundAngle = Math.atan2(seg.p2.y - seg.p1.y, segLen);
                    closestSegIdx = i;
                    closestT = t;
                }
            }
        }
        
        // If on ground, smoothly transition car's y and tilt to match track
        if (groundY !== null && (carPosition.y <= groundY + 0.5 || (carPosition.y <= groundY + 3 && carVelocity.y < 0))) {
            // Stop downward movement if we're landing
            if (carVelocity.y < 0) {
                carPosition.y = groundY;
                carVelocity.y = 0;
            } else {
                // Normal ground following behavior
                carPosition.y += (groundY - carPosition.y) * 0.5;
            }
            carOnGround = true;
            carVelocity.x *= groundFriction;
            carVelocity.z *= groundFriction;
            car.rotation.x += (groundAngle - car.rotation.x) * 0.2;
            
            // Update respawn point to last valid position on track
            if (closestSegIdx >= 0) {
                let seg = trackSegments[closestSegIdx];
                let segVec = new THREE.Vector3().subVectors(seg.p2, seg.p1);
                let yaw = Math.atan2(segVec.x, segVec.z);
                respawnPoint = {
                    pos: lerpVec3(seg.p1, seg.p2, closestT).clone(),
                    angle: yaw
                };
            }
        } else {
            carVelocity.x *= friction;
            carVelocity.z *= friction;
            car.rotation.x += (0 - car.rotation.x) * 0.1;
        }

        // Check collectible collisions
        checkCollectibleCollision();
        
        // Check finish line
        if (raceActive && !raceFinished) {
            checkFinishLine();
        }
        
        // Respawn if car falls off
        if (carPosition.y < -30 && respawnPoint) {
            fallCount++;
            lives--;
            updateGameUI();
            
            if (lives <= 0) {
                showGameOver();
                return;
            }
            
            carPosition.copy(respawnPoint.pos);
            carAngle = respawnPoint.angle;
            carVelocity.set(0, 0, 0);
            carSpeed = 0;
            car.rotation.x = 0;
        }

        car.position.copy(carPosition);
        car.rotation.y = carAngle;

        // Camera follows car
        let camTarget = carPosition.clone().add(new THREE.Vector3(
            Math.sin(carAngle) * cameraOffset.z,
            cameraOffset.y,
            Math.cos(carAngle) * cameraOffset.z
        ));
        camera.position.lerp(camTarget, 0.18);
        camera.lookAt(car.position);
    }

    // Update animate function for collectibles animation
    function animate() {
        requestAnimationFrame(animate);
        if (car) updateCar();
        
        // Update enemies
        updateEnemies();
        
        // Animate collectibles
        collectibles.forEach(item => {
            if (item.object && !item.collected) {
                item.object.rotation.y += 0.02;
                // Float up and down
                item.object.position.y = item.position.y + Math.sin(Date.now() * 0.002) * 0.5;
            }
        });
        
        // Broadcast position at a reasonable rate (10 times per second)
        if (peer && connections.length > 0 && Date.now() % 100 < 20) {
            broadcastPosition();
        }
        
        // Smooth update for each other player
        Object.values(otherPlayers).forEach(p => {
            p.mesh.position.lerp(p.position, 0.2);
            p.mesh.rotation.y = p.angle;
        });
        
        // Remove stale players (disconnected but not caught by close event)
        const now = Date.now();
        Object.keys(otherPlayers).forEach(id => {
            // Increase timeout to 20 seconds for better persistence
            if (now - otherPlayers[id].lastUpdate > 20000) {
                removeOtherPlayerCar(id);
            }
        });
        
        // Update minimap if it exists
        if (document.getElementById('minimap')) {
            updateMinimapMarkers();
        }
        
        renderer.render(scene, camera);
    }

    function clearScene() {
        if (!scene) return;
        for (let i = scene.children.length - 1; i >= 0; i--) {
            const obj = scene.children[i];
            if (obj.isMesh) {
                scene.remove(obj);
                if (obj.geometry) obj.geometry.dispose();
                if (obj.material) obj.material.dispose();
            }
        }
    }

    // --- Multiplayer Logic ---
    let peer = null;
    let connections = [];
    let isHost = false;
    let playerColor = '#' + Math.floor(Math.random()*16777215).toString(16);
    let otherPlayers = {}; // {peerId: {mesh, position, angle, lastUpdate}}
    let playerId = null;
    let playerIndices = {};      // maps peerId → numeric slot
    let nextPlayerIndex = 1;     // start with host = 1

    function joinOrCreateRoom(blockHash) {
        // Get player name from input
        playerName = document.getElementById('playerName').value.trim();
        if (!playerName) playerName = "Player" + Math.floor(Math.random() * 1000);

        // If already connected to a peer with the same block, do nothing
        if (peer && cachedBlockHash === blockHash) {
            console.log("Already connected with this block");
            return;
        }
        
        // If connected to a different block, disconnect first
        if (peer) {
            console.log("Disconnecting from previous room");
            connections.forEach(conn => {
                if (conn.open) conn.close();
            });
            connections = [];
            peer.disconnect();
            peer.destroy();
            peer = null;
            isHost = false;
        }

        // Now connect to new room
        showLoading(true, 10, "Connecting to room...");
        const hostPeer = new Peer(blockHash);

        hostPeer.on('open', id => {
            // Host: first to enter the room
            isHost = true;
            peer = hostPeer;
            playerId = id;
            playerIndices[id] = 1;
            // Only load block data if not already loaded
            loadBlockData(blockHash).then(() => {
                showLoading(false, 100, "Ready!");
            });
            peer.on('connection', handleConnection);

            // Show race controls for host
            document.getElementById('raceControls').style.display = 'block';
        });

        hostPeer.on('error', err => {
            // If room exists, join as client
            peer = new Peer();
            peer.on('open', id => {
                playerId = id;
                playerIndices[playerId] = nextPlayerIndex++;
                showLoading(true, 20, "Joining existing room...");
                const conn = peer.connect(blockHash);
                handleConnection(conn);
            });
        });

        // Add race control event listeners
        document.getElementById('startRaceButton').addEventListener('click', startRace);
    }

    function handleConnection(conn) {
        if (!playerIndices[conn.peer]) {
            playerIndices[conn.peer] = nextPlayerIndex++;
        }
        connections.push(conn);

        conn.on('open', () => {
            // Host sends blockData once to new joiner
            if (isHost && storedTransactions.length && blockMetadata) {
                conn.send({
                    type: 'init',
                    blockData: {
                        transactions: storedTransactions,
                        metadata: blockMetadata,
                        blockHash: cachedBlockHash
                    }
                });
            }
            // Everyone shares color & ID
            conn.send({
                type: 'playerInfo',
                playerColor: playerColor,
                playerId: playerId,
                playerIndex: playerIndices[playerId],
                playerName: playerName
            });
            showLoading(false, 100, "Connected!");
            updatePlayersList();
        });

        conn.on('data', data => {
            switch(data.type) {
                case 'init':
                    // Only load block if not already loaded
                    if (data.blockData && (!storedTransactions.length || cachedBlockHash !== data.blockData.blockHash)) {
                        storedTransactions = data.blockData.transactions;
                        blockMetadata = data.blockData.metadata;
                        cachedBlockHash = data.blockData.blockHash;
                        updateBlockInfo(blockMetadata);
                        createDrivingTrack(storedTransactions);
                    }
                    break;
                case 'playerInfo':
                    createOtherPlayerCar(data.playerId, data.playerColor, data.playerName);
                    playerIndices[data.playerId] = data.playerIndex || nextPlayerIndex++;
                    updatePlayersList();
                    break;
                case 'position':
                    updateOtherPlayerPosition(conn.peer, data);
                    break;
                case 'resetToStart':
                    if (respawnPoint) {
                        carPosition.copy(respawnPoint.pos);
                        carAngle = respawnPoint.angle;
                        carVelocity.set(0, 0, 0);
                        carSpeed = 0;
                        raceFinished = false;
                        finishLinePassed = false;
                    }
                    break;
                case 'startRaceCountdown':
                    startRaceCountdown();
                    break;
                case 'playerFinished':
                    // Record other player's finish time
                    raceTimes[data.playerId] = data.time;
                    // Show notification
                    const pIndex = playerIndices[data.playerId] || '?';
                    const minutes = Math.floor(data.time / 60000);
                    const seconds = Math.floor((data.time % 60000) / 1000);
                    const ms = data.time % 1000;
                    const timeStr = `${minutes}:${seconds.toString().padStart(2, '0')}.${ms.toString().padStart(3, '0')}`;
                    const notification = document.createElement('div');
                    notification.textContent = `Player ${pIndex} finished in ${timeStr}!`;
                    notification.style.position = 'absolute';
                    notification.style.bottom = '100px';
                    notification.style.left = '50%';
                    notification.style.transform = 'translateX(-50%)';
                    notification.style.color = '#ffa94d';
                    notification.style.background = 'rgba(0,0,0,0.7)';
                    notification.style.padding = '8px 16px';
                    notification.style.borderRadius = '4px';
                    notification.style.zIndex = '15';
                    document.body.appendChild(notification);
                    setTimeout(() => document.body.removeChild(notification), 5000);
                    break;
                case 'forceResetToStart':
                    // Force reset the player position to start using exact coordinates
                    if (data.startPos) {
                        carPosition.set(data.startPos.x, data.startPos.y, data.startPos.z);
                        carAngle = data.startPos.angle;
                        carVelocity.set(0, 0, 0);
                        carSpeed = 0;
                        raceFinished = false;
                        finishLinePassed = false;
                        
                        // Update respawn point too
                        respawnPoint = {
                            pos: new THREE.Vector3(data.startPos.x, data.startPos.y, data.startPos.z),
                            angle: data.startPos.angle
                        };
                    } else if (respawnPoint) {
                        // Fallback to local respawnPoint if no position data provided
                        carPosition.copy(respawnPoint.pos);
                        carAngle = respawnPoint.angle;
                        carVelocity.set(0, 0, 0);
                        carSpeed = 0;
                        raceFinished = false;
                        finishLinePassed = false;
                    }
                    break;
            }
        });

        conn.on('close', () => {
            connections = connections.filter(c => c !== conn);
            removeOtherPlayerCar(conn.peer);
            updatePlayersList();
        });
    }

    function updateCarColor(colorHex) {
        if (!car) return;
        // Convert hex string to number for Three.js
        const colorNum = parseInt(colorHex.replace('#', '0x'), 16);
        car.material.color.set(colorNum);
    }

    function updatePlayerCount() {
        document.getElementById('playerCount').textContent = connections.length;
    }

    function handlePeerMessage(peerId, data) {
        switch(data.type) {
            case 'init':
                // If we join and host sends block data, load that block
                if(data.blockHash) {
                    document.getElementById('blockHash').value = data.blockHash;
                    loadBlockData(data.blockHash);
                }
                createOtherPlayerCar(peerId, data.playerColor || '#ff0000', data.playerName);
                break;
                
            case 'position':
                updateOtherPlayerPosition(peerId, data);
                break;
        }
    }

    function createOtherPlayerCar(peerId, colorHex, playerName) {
        if (otherPlayers[peerId]) removeOtherPlayerCar(peerId);
        
        let geometry = new THREE.BoxGeometry(3, 2, 5);
        // Convert hex string to number for Three.js
        const colorNum = parseInt(colorHex.replace('#', '0x'), 16);
        let material = new THREE.MeshPhongMaterial({ 
            color: colorNum,
            emissive: new THREE.Color(colorNum).multiplyScalar(0.3) // Keep emissive for MeshPhongMaterial
        });
        let playerCar = new THREE.Mesh(geometry, material);
        scene.add(playerCar);
        
        // Add visible identifier with larger text and name
        const idx = playerIndices[peerId] || ('?' );
        const displayName = playerName || ('P' + idx);
        const playerLabel = createPlayerLabel('P' + idx, displayName);
        playerLabel.position.set(0, 4, 0); // Position higher above car
        playerLabel.scale.set(4, 2, 1);    // Make it larger
        playerCar.add(playerLabel);
        
        // Add highlighting effect with corrected material (no emissive)
        const highlightGeo = new THREE.BoxGeometry(3.5, 2.5, 5.5);
        const highlightMat = new THREE.MeshBasicMaterial({
            color: colorNum,
            transparent: true,
            opacity: 0.2,
            wireframe: false
        });
        const highlight = new THREE.Mesh(highlightGeo, highlightMat);
        playerCar.add(highlight);
        
        otherPlayers[peerId] = {
            mesh: playerCar,
            position: new THREE.Vector3(0, 5, 10),
            angle: 0,
            lastUpdate: Date.now(),
            color: colorHex,
            highlight: highlight
        };
        
        // Update player list display
        updatePlayersList();
        // Update minimap markers
        updateMinimapMarkers();
        
        console.log("Created player car for:", peerId);
    }
    
    // Create a floating label above player cars
    function createPlayerLabel(text, playerName) {
        const canvas = document.createElement('canvas');
        const context = canvas.getContext('2d');
        canvas.width = 128;
        canvas.height = 64;
        
        // Draw background - using semi-transparent for better visibility
        context.fillStyle = 'rgba(0,0,0,0.7)';
        context.fillRect(0, 0, canvas.width, canvas.height);
        
        // Draw border
        context.strokeStyle = '#ffffff';
        context.lineWidth = 2;
        context.strokeRect(2, 2, canvas.width-4, canvas.height-4);
        
        // Use provided name or default to numeric ID
        const displayText = playerName ? playerName : text;
        
        // Draw text - larger and bold
        context.font = 'bold 28px Arial';
        context.fillStyle = '#ffffff';
        context.textAlign = 'center';
        context.textBaseline = 'middle';
        context.fillText(displayText, canvas.width/2, canvas.height/2);
        
        // Create sprite
        const texture = new THREE.CanvasTexture(canvas);
        const material = new THREE.SpriteMaterial({ 
            map: texture,
            transparent: true,
            depthTest: false // Always render on top
        });
        const sprite = new THREE.Sprite(material);
        sprite.position.set(0, 3, 0); // Position above car
        sprite.scale.set(3, 1.5, 1);
        
        return sprite;
    }
    
    function updateOtherPlayerPosition(peerId, data) {
        if (!otherPlayers[peerId]) createOtherPlayerCar(peerId, data.color, data.playerName);
        const p = otherPlayers[peerId];
        p.position.set(data.x, data.y, data.z);
        p.angle = data.angle;
        p.lastUpdate = Date.now();
    }
    
    function broadcastPosition() {
        if (!peer || !carPosition) return;
        
        const posData = {
            type: 'position',
            x: carPosition.x,
            y: carPosition.y,
            z: carPosition.z,
            angle: carAngle,
            color: playerColor
        };
        
        connections.forEach(conn => {
            if (conn.open) {
                conn.send(posData);
            }
        });
    }
    
    function updatePlayersList() {
        const list = document.getElementById('playersList');
        if (!list) return; // Add safety check
        
        list.innerHTML = '<p><strong>Players:</strong></p>';
        
        // Add yourself
        const selfItem = document.createElement('div');
        selfItem.textContent = 'You' + (isHost ? ' (Host)' : '');
        selfItem.style.color = playerColor;
        list.appendChild(selfItem);
        
        // Add other players
        Object.keys(otherPlayers).forEach(id => {
            const playerItem = document.createElement('div');
            playerItem.textContent = id.substring(0, 8) + '...';
            playerItem.style.color = otherPlayers[id].color;
            list.appendChild(playerItem);
        });
    }

    // --- Minimap Implementation ---
    let minimapTrack = [];
    let minimapBounds = {
        minX: 0, maxX: 0,
        minZ: 0, maxZ: 0,
        width: 0, height: 0
    };
    
    function initMinimap() {
        // Create minimap container if it doesn't exist
        const minimap = document.getElementById('minimap');
        minimap.innerHTML = '';
        
        if (trackSegments && trackSegments.length > 0) {
            // Calculate track bounds
            calculateTrackBounds();
            
            // Create track visualization
            drawTrackOnMinimap();
        }
        
        // Create player marker
        const playerMarker = document.createElement('div');
        playerMarker.className = 'playerMarker';
        playerMarker.id = 'playerMarker';
        playerMarker.style.backgroundColor = playerColor;
        minimap.appendChild(playerMarker);
        
        // Update markers immediately
        updateMinimapMarkers();
    }
    
    function calculateTrackBounds() {
        minimapBounds.minX = Infinity;
        minimapBounds.maxX = -Infinity;
        minimapBounds.minZ = Infinity;
        minimapBounds.maxZ = -Infinity;
        
        // Find min/max coordinates of track
        trackSegments.forEach(segment => {
            minimapBounds.minX = Math.min(minimapBounds.minX, segment.p1.x, segment.p2.x);
            minimapBounds.maxX = Math.max(minimapBounds.maxX, segment.p1.x, segment.p2.x);
            minimapBounds.minZ = Math.min(minimapBounds.minZ, segment.p1.z, segment.p2.z);
            minimapBounds.maxZ = Math.max(minimapBounds.maxZ, segment.p1.z, segment.p2.z);
        });
        
        // Add some padding
        const padding = 20;
        minimapBounds.minX -= padding;
        minimapBounds.maxX += padding;
        minimapBounds.minZ -= padding;
        minimapBounds.maxZ += padding;
        
        minimapBounds.width = minimapBounds.maxX - minimapBounds.minX;
        minimapBounds.height = minimapBounds.maxZ - minimapBounds.minZ;
    }
    
    function drawTrackOnMinimap() {
        const minimap = document.getElementById('minimap');
        const minimapWidth = minimap.clientWidth;
        const minimapHeight = minimap.clientHeight;
        
        // Create SVG for track
        const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
        svg.setAttribute('width', '100%');
        svg.setAttribute('height', '100%');
        svg.style.position = 'absolute';
        
        // Draw each track segment
        trackSegments.forEach(segment => {
            // Convert 3D positions to minimap coordinates
            const x1 = mapValue(segment.p1.x, minimapBounds.minX, minimapBounds.maxX, 0, minimapWidth);
            const y1 = mapValue(segment.p1.z, minimapBounds.minZ, minimapBounds.maxZ, 0, minimapHeight);
            const x2 = mapValue(segment.p2.x, minimapBounds.minX, minimapBounds.maxX, 0, minimapWidth);
            const y2 = mapValue(segment.p2.z, minimapBounds.minZ, minimapBounds.maxZ, 0, minimapHeight);
            
            // Create line
            const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
            line.setAttribute('x1', x1);
            line.setAttribute('y1', y1);
            line.setAttribute('x2', x2);
            line.setAttribute('y2', y2);
            line.setAttribute('stroke', '#888');
            line.setAttribute('stroke-width', '2');
            svg.appendChild(line);
        });
        
        minimap.appendChild(svg);
    }
    
    function mapValue(value, inMin, inMax, outMin, outMax) {
        return ((value - inMin) * (outMax - outMin) / (inMax - inMin) + outMin);
    }
    
    function updateMinimapMarkers() {
        if (!minimapBounds || minimapBounds.width === 0) return;
        
        const minimap = document.getElementById('minimap');
        const minimapWidth = minimap.clientWidth;
        const minimapHeight = minimap.clientHeight;
        
        // Update player marker
        const playerMarker = document.getElementById('playerMarker');
        if (playerMarker && carPosition) {
            const playerX = mapValue(carPosition.x, minimapBounds.minX, minimapBounds.maxX, 0, minimapWidth);
            const playerZ = mapValue(carPosition.z, minimapBounds.minZ, minimapBounds.maxZ, 0, minimapHeight);
            playerMarker.style.left = playerX + 'px';
            playerMarker.style.top = playerZ + 'px';
        }
        
        // Update other players' markers
        Object.keys(otherPlayers).forEach(id => {
            const player = otherPlayers[id];
            let marker = document.getElementById('marker-' + id);
            
            if (!marker) {
                marker = document.createElement('div');
                marker.className = 'otherPlayerMarker';
                marker.id = 'marker-' + id;
                marker.style.backgroundColor = player.color;
                minimap.appendChild(marker);
            }
            
            const x = mapValue(player.position.x, minimapBounds.minX, minimapBounds.maxX, 0, minimapWidth);
            const z = mapValue(player.position.z, minimapBounds.minZ, minimapBounds.maxZ, 0, minimapHeight);
            
            marker.style.left = x + 'px';
            marker.style.top = z + 'px';
        });
        
        // Remove markers for disconnected players
        document.querySelectorAll('.otherPlayerMarker').forEach(marker => {
            const id = marker.id.replace('marker-', '');
            if (!otherPlayers[id]) {
                marker.remove();
            }
        });
    }
    
    function removeOtherPlayerCar(peerId) {
        if (otherPlayers[peerId]) {
            scene.remove(otherPlayers[peerId].mesh);
            delete otherPlayers[peerId];
            updatePlayersList();
            
            // Remove from minimap
            const marker = document.getElementById('marker-' + peerId);
            if (marker) marker.remove();
        }
    }
    
    function createStartAndFinishLines(track) {
        // Remove previous lines if they exist
        if (startLineObj && startLineObj.parent) startLineObj.parent.remove(startLineObj);
        if (finishLineObj && finishLineObj.parent) finishLineObj.parent.remove(finishLineObj);
        
        if (!track || !track.length) return;
        
        // Create start line at first track segment
        const startSeg = track[0];
        const startLineGeo = new THREE.PlaneGeometry(startSeg.width * 1.2, 3);
        const startLineMat = new THREE.MeshBasicMaterial({
            color: 0x00ff00,
            side: THREE.DoubleSide,
            transparent: true,
            opacity: 0.8
        });
        startLineObj = new THREE.Mesh(startLineGeo, startLineMat);
        
        // Position at the beginning of track
        startLineObj.position.copy(startSeg.p1);
        startLineObj.position.y += 0.2; // Slightly above track
        
        // Determine rotation
        const startDir = new THREE.Vector3().subVectors(startSeg.p2, startSeg.p1).normalize();
        startLineObj.rotation.y = Math.atan2(startDir.x, startDir.z) + Math.PI/2;
        startLineObj.rotation.x = Math.PI/2;
        
        scene.add(startLineObj);
        
        // Create finish line near the end of the track
        const finishSegIdx = Math.max(0, track.length - 3);
        const finishSeg = track[finishSegIdx];
        const finishLineGeo = new THREE.PlaneGeometry(finishSeg.width * 1.2, 3);
        const finishLineMat = new THREE.MeshBasicMaterial({
            color: 0xff0000,
            side: THREE.DoubleSide,
            transparent: true,
            opacity: 0.8
        });
        finishLineObj = new THREE.Mesh(finishLineGeo, finishLineMat);
        
        // Position at the end of track
        finishLineObj.position.copy(finishSeg.p2);
        finishLineObj.position.y += 0.2; // Slightly above track
        
        // Determine rotation
        const finishDir = new THREE.Vector3().subVectors(finishSeg.p2, finishSeg.p1).normalize();
        finishLineObj.rotation.y = Math.atan2(finishDir.x, finishDir.z) + Math.PI/2;
        finishLineObj.rotation.x = Math.PI/2;
        
        scene.add(finishLineObj);
    }
    
    function startRace() {
        if (!isHost || !connections.length) return;
        
        // Reset all players to start position and broadcast
        resetAllPlayersToStart();
        
        // Start countdown
        broadcastStartRace();
    }
    
    function resetAllPlayersToStart() {
        // Reset our own position to the very beginning of the track
        if (trackSegments && trackSegments.length > 0) {
            // Always use the very first segment
            const startSeg = trackSegments[0];
            const startPos = startSeg.p1.clone();
            startPos.y += 2; // Elevate slightly to avoid collision issues
            
            // Calculate angle based on direction from p1 to p2
            const startDir = new THREE.Vector3().subVectors(startSeg.p2, startSeg.p1).normalize();
            const startAngle = Math.atan2(startDir.x, startDir.z);
            
            // Force position reset for local player
            carPosition.copy(startPos);
            carAngle = startAngle;
            carVelocity.set(0, 0, 0);
            carSpeed = 0;
            raceFinished = false;
            finishLinePassed = false;
            
            // Update respawn point to match
            respawnPoint = {
                pos: startPos,
                angle: startAngle
            };
        }
        
        // Tell others to reset with an EXPLICIT command
        connections.forEach(conn => {
            if (conn.open) {
                conn.send({
                    type: 'forceResetToStart',
                    startPos: respawnPoint ? {
                        x: respawnPoint.pos.x,
                        y: respawnPoint.pos.y,
                        z: respawnPoint.pos.z,
                        angle: respawnPoint.angle
                    } : null
                });
            }
        });
    }
    
    function broadcastStartRace() {
        connections.forEach(conn => {
            if (conn.open) {
                conn.send({
                    type: 'startRaceCountdown'
                });
            }
        });
        
        // Start our own countdown too
        startRaceCountdown();
    }
    
    function startRaceCountdown() {
        const countdown = document.getElementById('countdown');
        countdown.style.display = 'block';
        
        // Lock controls during countdown
        controlsLocked = true;
        
        // 3...2...1...GO sequence
        countdown.textContent = '3';
        setTimeout(() => {
            countdown.textContent = '2';
            setTimeout(() => {
                countdown.textContent = '1';
                setTimeout(() => {
                    countdown.textContent = 'GO!';
                    raceActive = true;
                    raceStartTime = Date.now();
                    controlsLocked = false; // Enable controls on GO
                    
                    // Start spawning enemies
                    spawnEnemies();
                    
                    // Hide countdown after a moment
                    setTimeout(() => {
                        countdown.style.display = 'none';
                    }, 1000);
                }, 1000);
            }, 1000);
        }, 1000);
    }
    
    function checkFinishLine() {
        if (!finishLineObj || finishLinePassed) return;
        
        const distToFinish = carPosition.distanceTo(finishLineObj.position);
        if (distToFinish < 5) {
            finishLinePassed = true;
            const finishTime = Date.now() - raceStartTime;
            
            // Display finish time
            const minutes = Math.floor(finishTime / 60000);
            const seconds = Math.floor((finishTime % 60000) / 1000);
            const ms = finishTime % 1000;
            const timeStr = `${minutes}:${seconds.toString().padStart(2, '0')}.${ms.toString().padStart(3, '0')}`;
            
            const feedback = document.createElement('div');
            feedback.textContent = `Finish! Time: ${timeStr}`;
            feedback.style.position = 'absolute';
            feedback.style.top = '30%';
            feedback.style.left = '50%';
            feedback.style.transform = 'translate(-50%, -50%)';
            feedback.style.color = '#ff0000';
            feedback.style.fontSize = '2em';
            feedback.style.fontWeight = 'bold';
            feedback.style.zIndex = '100';
            document.body.appendChild(feedback);
            
            // Remove after a few seconds
            setTimeout(() => {
                document.body.removeChild(feedback);
            }, 5000);
            
            // Broadcast finish to other players
            if (peer && connections.length) {
                connections.forEach(conn => {
                    if (conn.open) {
                        conn.send({
                            type: 'playerFinished',
                            playerId: playerId,
                            time: finishTime
                        });
                    }
                });
            }
        }
    }
    
    // --- Enemy System ---
    function spawnEnemies() {
        // Clear any existing enemy spawn interval
        if (enemySpawnInterval) {
            clearInterval(enemySpawnInterval);
        }
        
        // Start spawning enemies every few seconds
        enemySpawnInterval = setInterval(() => {
            if (raceActive && !gameOver) {
                spawnFallingHammer();
            }
        }, 5000); // Spawn every 5 seconds
    }
    
    function spawnFallingHammer() {
        // Don't spawn if car position isn't defined yet
        if (!carPosition) return;
        
        // Create a position near the player but slightly ahead
        const offset = 30 + Math.random() * 40; // 30-70 units ahead
        const spread = 10 + Math.random() * 15; // 10-25 units to the side
        
        // Calculate position based on player direction
        const spawnPos = new THREE.Vector3(
            carPosition.x + (Math.cos(carAngle) * offset) + (Math.sin(carAngle) * spread * (Math.random() > 0.5 ? 1 : -1)),
            carPosition.y + 50, // High above
            carPosition.z + (Math.sin(carAngle) * offset) + (Math.cos(carAngle) * spread * (Math.random() > 0.5 ? 1 : -1))
        );
        
        // Create hammer geometry
        const hammerHead = new THREE.Group();
        
        // Head of hammer
        const headGeo = new THREE.BoxGeometry(4, 3, 4);
        const headMat = new THREE.MeshPhongMaterial({ color: 0x888888 });
        const head = new THREE.Mesh(headGeo, headMat);
        hammerHead.add(head);
        
        // Handle of hammer
        const handleGeo = new THREE.CylinderGeometry(0.5, 0.5, 8);
        const handleMat = new THREE.MeshPhongMaterial({ color: 0x8B4513 });
        const handle = new THREE.Mesh(handleGeo, handleMat);
        handle.position.y = -5.5;
        handle.rotation.x = Math.PI / 2;
        hammerHead.add(handle);
        
        // Warning indicator (red cone)
        const warnGeo = new THREE.ConeGeometry(1, 4, 8);
        const warnMat = new THREE.MeshBasicMaterial({ 
            color: 0xff0000,
            transparent: true,
            opacity: 0.7
        });
        const warning = new THREE.Mesh(warnGeo, warnMat);
        warning.position.y = -10;
        warning.rotation.x = Math.PI;
        hammerHead.add(warning);
        
        // Add to scene
        scene.add(hammerHead);
        hammerHead.position.copy(spawnPos);
        
        // Store enemy data
        const enemy = {
            mesh: hammerHead,
            position: spawnPos.clone(),
            velocity: new THREE.Vector3(0, 0, 0),
            active: true,
            impactPoint: new THREE.Vector3(spawnPos.x, 0, spawnPos.z),
            warning: warning
        };
        
        enemies.push(enemy);
        
        // Show danger indicator
        showDangerWarning();
    }
    
    function updateEnemies() {
        // Update each enemy
        for (let i = enemies.length - 1; i >= 0; i--) {
            const enemy = enemies[i];
            if (!enemy.active) continue;
            
            // Apply gravity
            enemy.velocity.y -= 0.4; // Faster than car gravity
            
            // Move hammer
            enemy.position.add(enemy.velocity);
            enemy.mesh.position.copy(enemy.position);
            
            // Add spin effect
            enemy.mesh.rotation.z += 0.05;
            
            // Check for track collision using similar logic as the car
            let hitTrack = false;
            for (let j = 0; j < trackSegments.length; j++) {
                let seg = trackSegments[j];
                let segVec = new THREE.Vector3().subVectors(seg.p2, seg.p1);
                let segLen = segVec.length();
                let toCar = new THREE.Vector3().subVectors(enemy.position, seg.p1);
                let t = Math.max(0, Math.min(1, segVec.dot(toCar) / (segLen * segLen)));
                let closest = lerpVec3(seg.p1, seg.p2, t);
                let distXZ = Math.sqrt(
                    Math.pow(enemy.position.x - closest.x, 2) +
                    Math.pow(enemy.position.z - closest.z, 2)
                );
                if (distXZ < seg.width / 2) {
                    let yOnTrack = closest.y + 1.5;
                    if (enemy.position.y < yOnTrack && enemy.velocity.y < 0) {
                        // Position the hammer on the track surface
                        enemy.position.y = yOnTrack;
                        hitTrack = true;
                        break;
                    }
                }
            }
            
            // Handle impact on track or ground
            if (hitTrack || enemy.position.y < 1.5) {
                // Disable enemy
                enemy.active = false;
                
                // Create impact effect
                createImpactEffect(enemy.position.clone());
                
                // Check for collision with player
                const distToPlayer = new THREE.Vector2(enemy.position.x, enemy.position.z)
                    .distanceTo(new THREE.Vector2(carPosition.x, carPosition.z));
                
                if (distToPlayer < 6) {
                    // Hit player!
                    handleHammerHit();
                }
                
                // Remove after delay
                setTimeout(() => {
                    if (enemy.mesh && enemy.mesh.parent) {
                        scene.remove(enemy.mesh);
                        enemies.splice(enemies.indexOf(enemy), 1);
                    }
                }, 3000);
            }
        }
    }
    
    function createImpactEffect(position) {
        // Create dust particles
        const particleCount = 20;
        const particles = new THREE.Group();
        
        for (let i = 0; i < particleCount; i++) {
            const particleGeo = new THREE.SphereGeometry(0.3, 4, 4);
            const particleMat = new THREE.MeshBasicMaterial({
                color: 0xbbbbbb,
                transparent: true,
                opacity: 0.8
            });
            const particle = new THREE.Mesh(particleGeo, particleMat);
            
            // Random position around impact
            particle.position.x = position.x + (Math.random() * 6 - 3);
            particle.position.y = position.y + (Math.random() * 2);
            particle.position.z = position.z + (Math.random() * 6 - 3);
            
            // Random velocity
            particle.userData.velocity = new THREE.Vector3(
                Math.random() * 0.3 - 0.15,
                Math.random() * 0.2 + 0.1,
                Math.random() * 0.3 - 0.15
            );
            
            particles.add(particle);
        }
        
        scene.add(particles);
        
        // Remove after animation
        setTimeout(() => {
            scene.remove(particles);
        }, 2000);
        
        // Create shockwave ring
        const ringGeo = new THREE.RingGeometry(0.5, 1.5, 16);
        const ringMat = new THREE.MeshBasicMaterial({
            color: 0xffffff,
            transparent: true,
            opacity: 0.7,
            side: THREE.DoubleSide
        });
        const ring = new THREE.Mesh(ringGeo, ringMat);
        ring.position.copy(position);
        ring.position.y = 0.2;
        ring.rotation.x = -Math.PI / 2;
        scene.add(ring);
        
        // Animate expansion and fade
        let scale = 1;
        const expandRing = setInterval(() => {
            scale += 1;
            ring.scale.set(scale, scale, scale);
            ring.material.opacity -= 0.05;
            
            if (ring.material.opacity <= 0) {
                clearInterval(expandRing);
                scene.remove(ring);
            }
        }, 100);
    }
    
    function handleHammerHit() {
        // Visual effect
        carVelocity.y = 3; // Bounce up
        
        // Reduce life
        lives--;
        updateGameUI();
        
        if (lives <= 0) {
            showGameOver();
        }
        
        // Visual feedback
        const feedback = document.createElement('div');
        feedback.textContent = 'SMASHED!';
        feedback.style.position = 'absolute';
        feedback.style.top = '50%';
        feedback.style.left = '50%';
        feedback.style.transform = 'translate(-50%, -50%)';
        feedback.style.color = '#ff0000';
        feedback.style.fontSize = '3em';
        feedback.style.fontWeight = 'bold';
        feedback.style.textShadow = '0 0 10px #ff0000';
        feedback.style.pointerEvents = 'none';
        feedback.style.zIndex = '20';
        document.body.appendChild(feedback);
        
        setTimeout(() => {
            document.body.removeChild(feedback);
        }, 1000);
    }
    
    function showDangerWarning() {
        const indicator = document.getElementById('dangerIndicator');
        indicator.style.display = 'block';
        
        // Update the style so it's more visible
        indicator.style.top = '20%'; // Move higher up
        indicator.style.background = 'rgba(0,0,0,0.5)';
        indicator.style.padding = '10px 20px';
        indicator.style.borderRadius = '8px';
        
        setTimeout(() => {
            indicator.style.display = 'none';
        }, 2000);
    }

    // Add event listeners
    function addGameEventListeners() {
        document.getElementById('restartGame').addEventListener('click', restartGame);
        
        // Prevent scrolling
        window.addEventListener('keydown', e => {
            if(['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'ShiftLeft'].includes(e.code)) {
                e.preventDefault();
            }
            keys[e.code] = true;
        });
    }

    // --- UI and Startup ---
    document.getElementById('blockForm').onsubmit = function(e) {
        e.preventDefault();
        const blockHash = document.getElementById('blockHash').value.trim();
        if (!blockHash) return;
        joinOrCreateRoom(blockHash);
    };

    window.onload = function() {
        initThreeJS();
        updateGameUI();
        addGameEventListeners();
        
        // Get player name from localStorage if available
        const savedName = localStorage.getItem('playerName');
        if (savedName) {
            document.getElementById('playerName').value = savedName;
            playerName = savedName;
        }
        
        // Save name when changed
        document.getElementById('playerName').addEventListener('change', (e) => {
            localStorage.setItem('playerName', e.target.value);
            playerName = e.target.value;
        });
        
        // Add jump indicator update
        const jumpIndicator = document.getElementById('jumpIndicator');
        setInterval(() => {
            if (canJump) {
                jumpIndicator.textContent = "Jump Ready";
                jumpIndicator.classList.remove('cooldown');
            } else {
                jumpIndicator.textContent = "Jump Cooldown";
                jumpIndicator.classList.add('cooldown');
            }
        }, 100);
        
        // Fetch latest block more robustly
        fetchLatestBlockInfo().then(block => {
            if (block) {
                animate(); // Start animation after block is loaded
                joinOrCreateRoom(block); // Join game with latest block
            } else {
                // Use a default block if all else fails
                const defaultBlock = '783000';
                document.getElementById('blockHash').value = defaultBlock;
                animate();
                joinOrCreateRoom(defaultBlock);
            }
        }).catch(error => {
            console.error("Error in block loading:", error);
            // Fallback to default block
            const defaultBlock = '783000';
            document.getElementById('blockHash').value = defaultBlock;
            animate();
            joinOrCreateRoom(defaultBlock);
        });
    };
    </script>
</body>
</html>
